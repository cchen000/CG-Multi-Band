
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>main</title><meta name="generator" content="MATLAB 9.2"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2024-01-30"><meta name="DC.source" content="main.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; } 

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style></head><body><div class="content"><h2>Contents</h2><div><ul><li><a href="#3">main: load settings</a></li><li><a href="#4">main: maximize network throughput</a></li><li><a href="#9">main: passing parameters</a></li><li><a href="#10">main: print out information</a></li><li><a href="#11">main: plot result</a></li><li><a href="#12">main: deal with function output</a></li><li><a href="#17">CG: pre-calculate ColorLessLightPathSet</a></li><li><a href="#19">CG-step 1: initialize configuration</a></li><li><a href="#20">CG-step 2: process new configuration and current set</a></li><li><a href="#21">CG-step 3: Loop begins</a></li><li><a href="#22">CG-step 4: RMP with integer constraints</a></li><li><a href="#23">CG-step 5: configure wavelength</a></li><li><a href="#24">CG-step 6: data post-processing</a></li><li><a href="#28">ILP-initialize parameters</a></li><li><a href="#29">ILP-step1: define variable</a></li><li><a href="#30">ILP-step2: add constraints</a></li><li><a href="#31">ILP-step3: set objective</a></li><li><a href="#32">ILP-step4: solve problem</a></li><li><a href="#37">SequentialLoadingHeu: initialize</a></li><li><a href="#38">SequentialLoadingHeu-step1: generate demands</a></li><li><a href="#39">SequentialLoadingHeu-step2: loading demands sequentially</a></li><li><a href="#40">SequentialLoadingHeu-step3: return demands and capacity</a></li></ul></div><pre class="codeinput"><span class="keyword">function</span> [varargout] = main(SimulationSetting)
</pre><pre>main: simulation setup, start compuation, and print and plot results.</pre><pre class="language-matlab">Related <span class="string">paper</span> <span class="string">:</span> <span class="string">&lt;Throughput</span> <span class="string">Maximization</span> <span class="string">in</span> <span class="string">Multi-Band</span> <span class="keyword">...</span>
                    <span class="string">Optical</span> <span class="string">Networks</span> <span class="string">with</span> <span class="string">Column</span> <span class="string">Generation&gt;</span>
</pre><pre>------------------------------
Output:</pre><pre class="language-matlab">- <span class="string">'varargout'</span>
    LightPathSet:                   lightpath information
    isEdgeUseSlot:                  network block <span class="string">information</span>
    info:                           computation (time, results, <span class="keyword">...</span><span class="comment">)</span>
</pre><pre class="language-matlab">- log file:
   <span class="string">'Results_heu_log.txt'</span>              log <span class="string">of</span> <span class="string">sequential</span> <span class="string">algorithm</span>
</pre><pre>    'Results_Configuration.txt'        log of CG;
    'Results_TableCG.txt'              log of detailed CG;</pre><pre>    'Results_LightPathSetPerCommodity' lightpath information
    'Results_Table.txt'                log of current algorithm;</pre><pre>------------------------------
 key parameters
 SimulationSetting : [struct] user-given parameters;
 Networks : [struct] basic network parameters, ...
                   (nodes, topologies, distance matrix, etc.);
 NetState : [struct] network state accompliashed with network, ...
            including no. slots, LinkSlotBlock.
 CandidateOpticalBand : [class 'OpticalBand' array] candidate bands, ...
                     	e.g., CBand, LBand;
 CandidateTransponder : [class 'Transceiver' array] candidate
                         transceivers at x GBd, including spectral
                         efficiency, SNR, bandwidth, etc.
 CandidateModFormat : [class 'TransmissionMode' array]
                     transmission modes with different MFs and FECs,
                      e.g., PM_BPSK with 7% FEC overhead. We only show
                      three properties, i.e., required SNR, capacity,
                      and transmission reach;
 LightPathSet : [class  'LightPath'] lightpaths in a network.
 MultiCommodityFlow : [class 'Demand']
 MaxThroughputOptions : [class 'MaxOption'] user-defined options
                           during optimization.
------------------------------</pre><pre class="language-matlab">Note:
* <span class="string">'Commodity/NodePair/Connection'</span>: a unique <span class="string">source</span> <span class="string">and</span> <span class="string">destination</span> <span class="string">node</span>
            pair, in <span class="string">a</span> <span class="string">network.</span> <span class="string">At</span> <span class="string">most</span> <span class="string">one</span> <span class="string">entity</span> <span class="string">exists</span> <span class="string">for</span> <span class="string">(s,d).</span>
* <span class="string">'demand/flow'</span> : the possible <span class="string">user</span> <span class="string">traffic</span> <span class="string">[bps].</span> <span class="string">It</span> <span class="string">can</span> <span class="string">be</span>
            repeated.
* <span class="string">'CapacityMatrix'</span> : this is <span class="string">initialized</span> <span class="string">by</span> <span class="string">regarding</span> <span class="string">lightpath</span> <span class="string">as</span>
        p_{s,d,k,ob,tb,m}, so <span class="string">that</span> <span class="string">transmission</span> <span class="string">capacity</span> <span class="string">of</span> <span class="string">lightpath</span>
        can <span class="string">be</span> <span class="string">easily</span> <span class="string">retrieved</span> <span class="string">by</span> <span class="string">indexing</span> <span class="string">function.</span>
* <span class="string">'Channel/Slot/Wavelength'</span> : They are <span class="string">totally</span> <span class="string">equivalent</span> <span class="string">in</span> <span class="string">representing</span>
        the <span class="string">basic</span> <span class="string">spectrum</span> <span class="string">unit</span> <span class="string">in</span> <span class="string">this</span> <span class="string">project.</span>
        Further <span class="string">refinements</span> <span class="string">to</span> <span class="string">distinguish</span> <span class="string">channels</span> <span class="string">and</span> <span class="string">slots</span> <span class="string">can</span> <span class="string">be</span>
        made, <span class="keyword">if</span> we regard <span class="string">'a'</span> <span class="string">and</span> <span class="string">'a+1'</span> <span class="string">slots</span> <span class="string">as</span> <span class="string">two</span> <span class="string">channels</span>, and
        <span class="string">'a,a+1'</span> as <span class="string">a</span> <span class="string">third</span> <span class="string">channel.</span>
</pre><pre>Author: cao.chen
Log:
Derived from &lt;simple_main_sequential_loadingMultiBandsv2.m&gt;  -  22nd, Jun, 2023.
Review code. - 7, Nov. 2023.
Review code. - 11, Jan. 2024.</pre><h2 id="3">main: load settings</h2><pre class="codeinput">ImportLib();
<span class="comment">% ==============================</span>
<span class="comment">% Load settings</span>
<span class="comment">% ==============================</span>
<span class="keyword">if</span> nargin==0
    ConfigFile          = <span class="string">'setup/SimulationSetup_EX4.yaml'</span>;
    SimulationSetting   = ReadYaml(ConfigFile);
<span class="keyword">end</span>
networkTag          = SimulationSetting.network_tag;
rngSeed             = SimulationSetting.random_seed;

<span class="comment">% ==============================</span>
<span class="comment">% Load optical bands</span>
<span class="comment">% ==============================</span>
[TotalOpticalBand, nTotalOpticalBand, frequencySlots] = <span class="keyword">...</span>
    initializeOpticalBand(SimulationSetting);
keyName                       =<span class="string">'name'</span>;
[CandidateOpticalBand,nCandidateOpticalBand] = <span class="keyword">...</span>
    getClassByFields( <span class="keyword">...</span>
    SimulationSetting.widebandset <span class="keyword">...</span>
    , keyName <span class="keyword">...</span>
    , TotalOpticalBand <span class="keyword">...</span>
    );
<span class="comment">% keyName                       = 'centerFrequency';</span>
<span class="comment">% CandidateOpticalBand          = sortClass(CandidateOpticalBand, keyName);</span>
assert(<span class="keyword">...</span>
    nCandidateOpticalBand == SimulationSetting.number_of_bands <span class="keyword">...</span>
    , <span class="string">'MATLAB:main:UnMatchedSize'</span><span class="keyword">...</span>
    , <span class="string">'Wrong optical band setting'</span>);


<span class="comment">% ==============================</span>
<span class="comment">% Load transceiver parameters</span>
<span class="comment">% ==============================</span>
[TotalTransceiverAddNull, nTotalTransceiver] <span class="keyword">...</span>
            = initializeTransceiver(SimulationSetting);
keyName     = <span class="string">'name'</span>;
[CandidateTransceiver, nCandidateTransceiver] <span class="keyword">...</span>
            = getClassByFields(<span class="keyword">...</span>
            SimulationSetting.transponder_set <span class="keyword">...</span>
            , keyName <span class="keyword">...</span>
            , TotalTransceiverAddNull <span class="keyword">...</span>
            );
assert(<span class="keyword">...</span>
    nCandidateTransceiver == SimulationSetting.number_of_transponder <span class="keyword">...</span>
    , <span class="string">'MATLAB:main:UnMatchedSize'</span><span class="keyword">...</span>
    , <span class="string">'Wrong TRx setting'</span><span class="keyword">...</span>
    );

<span class="comment">% ==============================</span>
<span class="comment">% Load transmission modes</span>
<span class="comment">% ==============================</span>
[TotalTransmissionMode, nTotalTransmissionMode] <span class="keyword">...</span>
            =  initializeTransmissionMode(SimulationSetting);
keyName     = <span class="string">'name'</span>;
[CandidateTRxMod,nCandidateTRxMod] <span class="keyword">...</span>
            = getClassByFields(<span class="keyword">...</span>
                SimulationSetting.transmission_mode_set <span class="keyword">...</span>
                , keyName <span class="keyword">...</span>
                , TotalTransmissionMode);
assert(<span class="keyword">...</span>
    nCandidateTRxMod == SimulationSetting.number_of_transmission_modes<span class="keyword">...</span>
    , <span class="string">'MATLAB:main:UnMatchedSize'</span><span class="keyword">...</span>
    , <span class="string">'Wrong transission mode setting'</span>);

<span class="comment">% % ------------------------------</span>
<span class="comment">% #demo: fixed vs. flexible capacity;(try search 'demo');</span>
<span class="comment">% CandidateTRxMod = ...</span>
<span class="comment">%   getClassByFields('PM_QPSK', 'name', TotalTransmissionMode);</span>
<span class="comment">% nCandidateTRxMod = 1;</span>
<span class="comment">% % ------------------------------</span>
<span class="comment">% ==============================</span>
<span class="comment">% Load traffic demand</span>
<span class="comment">% ==============================</span>
MultiCommodityFlow <span class="keyword">...</span>
    = initializeCommodityFlows(SimulationSetting);

<span class="comment">% ==============================</span>
<span class="comment">% Load networks</span>
<span class="comment">% ==============================</span>
networkFileName     = <span class="keyword">...</span>
    sprintf(<span class="string">'networks/mat_%s/%s.mat'</span> <span class="keyword">...</span>
    , networkTag <span class="keyword">...</span>
    , networkTag);
load(networkFileName);
OpticalNetworks = initializeNetworks(<span class="keyword">...</span>
    networkTag<span class="keyword">...</span>
    , distanceSpanMatrix<span class="keyword">...</span>
    , longitudeDegreeArray<span class="keyword">...</span>
    , latitudeDegreeArray<span class="keyword">...</span>
    ); <span class="comment">% user-defined initialization function.</span>
<span class="comment">% showNetworks(logical(distanceSpanMatrix) ...</span>
<span class="comment">%     , longitudeDegreeArray ...</span>
<span class="comment">%     , latitudeDegreeArray); % show Networks if required.</span>

<span class="comment">% ==============================</span>
<span class="comment">% Load network state</span>
<span class="comment">% ==============================</span>
netStateFileName = sprintf(<span class="keyword">...</span>
    <span class="string">'Networks/mat_%s/netstate_%s%s.mat'</span> <span class="keyword">...</span>
    , networkTag <span class="keyword">...</span>
    , networkTag <span class="keyword">...</span>
    , CandidateTransceiver.name <span class="keyword">...</span>
    );
<span class="keyword">if</span> exist(netStateFileName)
    load(netStateFileName);
<span class="keyword">else</span> <span class="comment">%</span>
    NetState = initializeNetworkState(OpticalNetworks<span class="keyword">...</span>
        , SimulationSetting.candidate_routes <span class="keyword">...</span>
        , SimulationSetting.number_of_slots <span class="keyword">...</span>
        , MultiCommodityFlow);
    save(netStateFileName, <span class="string">'NetState'</span>);
<span class="keyword">end</span>

<span class="comment">% ==============================</span>
<span class="comment">% Update LinkSlotBlock</span>
<span class="comment">%   - Import optical band profile</span>
<span class="comment">%   - Update edgeSlotBlock (edge spectrum status, slot's optical band ID)</span>
<span class="comment">% ==============================</span>
bandProfileSetting     = ReadYaml(SimulationSetting.wideband_file);
isEdgeUseOpticalBand   = initializeFiberOpticalBand( <span class="keyword">...</span>
    OpticalNetworks, CandidateOpticalBand, bandProfileSetting);

[CandidateOpticalBand] = assignSlotPosition(CandidateOpticalBand);
[isEdgeUseSlot, opticalBandNoOfSlot] <span class="keyword">...</span>
                       = initializeEdgeSlot(<span class="keyword">...</span>
                       isEdgeUseOpticalBand <span class="keyword">...</span>
                       , CandidateOpticalBand );
assert(<span class="keyword">...</span>
    size(isEdgeUseSlot,2) == NetState.nSlots <span class="keyword">...</span>
    , <span class="string">'MATLAB:main:UnMatchedSize'</span> <span class="keyword">...</span>
    , <span class="string">'wrong slots setting'</span> <span class="keyword">...</span>
    );  <span class="comment">% if slot number neq total given slots.</span>

NetState.isEdgeUseSlot       = isEdgeUseSlot;
NetState.opticalBandNoOfSlot = opticalBandNoOfSlot;

<span class="comment">%  - user parameter</span>
NetState.userParameters      = []; <span class="comment">% default parameter;</span>
<span class="comment">% Note : This is a read/write interface.</span>
<span class="comment">%       You can use it for debugging netstate-related parameters.</span>
<span class="comment">%</span>
<span class="comment">% Example</span>
<span class="comment">%     ILP : null</span>
<span class="comment">%     SequentialHeu : searching index matrix for respective elements</span>
<span class="comment">%                   of (s,d) on index (k,w);</span>
<span class="comment">%     CG : solving times, no. iterations, optimal bound of LP, etc. ...</span>


<span class="comment">% ==============================</span>
<span class="comment">% Capacity initialzation, assign</span>
<span class="comment">%   - Baud*SE for p_{s,d,k,ob,tb,m}, if worstSNR &gt;= REQSNR,</span>
<span class="comment">%   - 0, otherwise.</span>
<span class="comment">% ==============================</span>
<span class="comment">%</span>
<span class="comment">%   1. margin for path p_{s,d,k,ob,tb,m}, e.g., margin = 10*log(SNRREQ), considering</span>
<span class="comment">%       - a fixed margin for all;</span>
<span class="comment">%       - optical bands margin;</span>

<span class="comment">%   fixed margin</span>
minReqMargin0 = 1;

<span class="comment">%     optical band margin;</span>
minReq1_Pathsdk_atOpticalBand_atTRx_withTRxMod = zeros(<span class="keyword">...</span>
    OpticalNetworks.nNodes, <span class="keyword">...</span>
    OpticalNetworks.nNodes, <span class="keyword">...</span>
    NetState.nRoutes, <span class="keyword">...</span>
    nCandidateOpticalBand, <span class="keyword">...</span>
    nCandidateTransceiver, <span class="keyword">...</span>
    nCandidateTRxMod<span class="keyword">...</span>
    );
<span class="comment">% Note: we use '_' for naming.</span>

<span class="keyword">for</span> iOpticalBand = 1 : nCandidateOpticalBand
    thisBand = CandidateOpticalBand(iOpticalBand);
    minReq1_Pathsdk_atOpticalBand_atTRx_withTRxMod(<span class="keyword">...</span>
        1:OpticalNetworks.nNodes, <span class="keyword">...</span>
        1:OpticalNetworks.nNodes,<span class="keyword">...</span>
        1:NetState.nRoutes,<span class="keyword">...</span>
        iOpticalBand, <span class="keyword">...</span>
        1:nCandidateTransceiver, <span class="keyword">...</span>
        1:nCandidateTRxMod) <span class="keyword">...</span>
        = dB2lin(thisBand.SNRpenaltydB);
<span class="keyword">end</span>
minReqFull_Pathsdk_atOpticalBand_atTRx_withTRxMod <span class="keyword">...</span><span class="comment"> % linking all margins.</span>
    = minReqMargin0 .* minReq1_Pathsdk_atOpticalBand_atTRx_withTRxMod;

<span class="comment">%   2. REQSNR : transforming margin into required SNR.</span>
minRequiredSNR_Pathsdk_atOpticalBand_atTRXBaud_withM = <span class="keyword">...</span>
    initializeRequiredSNR(<span class="keyword">...</span>
    minReqFull_Pathsdk_atOpticalBand_atTRx_withTRxMod, CandidateTRxMod);

<span class="comment">%   3. Capacity initialzation,</span>
<span class="comment">%       worstSNR: the SNR in worst-case transmission</span>
SNRAfterFirstSpan = 120; <span class="comment">% around 10^(20.7/10);</span>
worstSNR_Pathsdk_atOpticalBand_atBaud_withM = <span class="keyword">...</span>
    SNRAfterFirstSpan <span class="keyword">...</span>
    ./ repmat(NetState.lengthOfPathOfsdk,<span class="keyword">...</span>
    1,1,1,nCandidateOpticalBand,nCandidateTransceiver,nCandidateTRxMod);

CapacityMatrix_kthRoute_atOpticalBand_atTRXBaud_withM = <span class="keyword">...</span>
    assignCapacityForAllCandidates(<span class="keyword">...</span>
    worstSNR_Pathsdk_atOpticalBand_atBaud_withM, <span class="keyword">...</span>
    minRequiredSNR_Pathsdk_atOpticalBand_atTRXBaud_withM, <span class="keyword">...</span>
    CandidateTransceiver, <span class="keyword">...</span>
    CandidateTRxMod);

<span class="comment">% ==============================</span>
<span class="comment">% Check before use</span>
<span class="comment">% ==============================</span>
<span class="comment">% check frequency slots from two sources :</span>
<span class="comment">%   - default no. slots (given SimulationSettings.frequency_slots).</span>
<span class="comment">%   - transceiver's baud-rate.</span>
<span class="keyword">for</span> iTransceiver = 1 : nCandidateTransceiver
    thisTRx = CandidateTransceiver(iTransceiver);
    assert(thisTRx.GBaud == SimulationSetting.frequency_slots<span class="keyword">...</span>
        , <span class="string">'MATLAB:main:UnMatchedSize'</span><span class="keyword">...</span>
        , <span class="string">'Wrong frequency slots setting'</span><span class="keyword">...</span>
        );
<span class="keyword">end</span>
</pre><h2 id="4">main: maximize network throughput</h2><p><b>Max Option settings</b></p><pre class="codeinput"><span class="comment">%  1. ILPmodel</span>
algorithmName = <span class="string">'ColumnGenerationHeu'</span>;
<span class="comment">% e.g., ColumnGenerationHeu;SequentialLoadingHeu;ILPmodel</span>
MaxThroughputOptions = MaxOption(algorithmName);
MaxThroughputOptions = setSolverOption(MaxThroughputOptions <span class="keyword">...</span>
    , <span class="string">'costLimit'</span>, SimulationSetting.limited_transceivers<span class="keyword">...</span>
    , <span class="string">'rngSeed'</span>,   rngSeed<span class="keyword">...</span>
    );
</pre><pre>   MaxThroughputOptions = setSolverOption(MaxThroughputOptions, ...
       'algorithmOption.ILP_FeasibilityTol', SimulationSetting.ILP_FeasibilityTol, ...
       'algorithmOption.ILP_OptimalityTol',  SimulationSetting.ILP_OptimalityTol,...
       'algorithmOption.ILP_MIPGap',         SimulationSetting.ILP_mingap, ...
       'algorithmOption.ILP_TimeLimit',      SimulationSetting.ILP_TimeLimit...
       ); % For algorithmName = 'ILPmodel'</pre><pre class="codeinput">    MaxThroughputOptions = setSolverOption(MaxThroughputOptions, <span class="keyword">...</span>
        <span class="string">'algorithmOption.strategyLPConfigInitial'</span>, <span class="string">'SequentialLoadingHeu'</span>, <span class="keyword">...</span>
        <span class="keyword">...</span><span class="comment">%'1LP per configuration', 'kSP-FF per configuration' 'SequentialLoadingHeu'</span>
        <span class="string">'algorithmOption.RMPINTOptimalityTol'</span>,    SimulationSetting.rmpINT_optimality_tol,<span class="keyword">...</span>
        <span class="string">'algorithmOption.RMPINTMIPgap'</span>,           SimulationSetting.rmpINT_mingap, <span class="keyword">...</span>
        <span class="string">'algorithmOption.RMPINTTimeLimit'</span>,        SimulationSetting.rmpINT_TimeLimit,<span class="keyword">...</span>
        <span class="string">'algorithmOption.rmp_mingap'</span>,             SimulationSetting.rmp_mingap, <span class="keyword">...</span>
        <span class="string">'algorithmOption.rmp_TimeLimit'</span>,          SimulationSetting.rmp_TimeLimit, <span class="keyword">...</span>
        <span class="string">'algorithmOption.ConfigGroupSorting'</span>,     <span class="string">'number_of_Reps'</span>,<span class="keyword">...</span>
        <span class="keyword">...</span><span class="comment"> %  'number_of_FSs', 'number_of_LPs', 'number_of_Reps', 'randomly',</span>
        <span class="string">'algorithmOption.ConfigGroupDirection'</span>,   <span class="string">'descend'</span>, <span class="keyword">...</span>
        <span class="keyword">...</span><span class="comment"> %  'ascend' or 'descend',</span>
        <span class="string">'algorithmOption.ConfigSingleDirection'</span>,  <span class="string">'default'</span>,<span class="keyword">...</span>
        <span class="keyword">...</span><span class="comment"> %  'randomly', 'default'</span>
        <span class="string">'algorithmOption.pricing_optimality_tol'</span>, SimulationSetting.pricing_optimality_tol, <span class="keyword">...</span>
        <span class="string">'algorithmOption.pricing_mingap'</span>,         SimulationSetting.pricing_mingap<span class="keyword">...</span>
        ); <span class="comment">% For algorithmName = 'ColumnGenerationHeu'</span>
</pre><pre>   MaxThroughputOptions = setSolverOption(MaxThroughputOptions, ...
       'algorithmOption.LoadingStrategy',      'kSP-FF', ...
       ...%'FF-kSP', 'kSP-FF'
       'algorithmOption.TerminateStrategy',    'First-blocking'...
       ); % For algorithmName = 'SequentialLoadingHeu'</pre><pre>Add lightpath constraint if required; #temproaliry option</pre><pre>     MaxThroughputOptions.costLimit = 8000;</pre><pre class="codeinput">fprintf(sprintf(<span class="string">'%sN%dR%gTRx%g\n'</span>, networkTag, <span class="keyword">...</span>
    OpticalNetworks.nNodes,<span class="keyword">...</span>
    rngSeed, <span class="keyword">...</span>
    CandidateTransceiver(1).GBaud));
[resultNetworkThroughput, NetState, LightPathSet, computationTime] = <span class="keyword">...</span>
    MaxThroughput(algorithmName, <span class="keyword">...</span>
    OpticalNetworks, <span class="keyword">...</span>
    NetState, <span class="keyword">...</span>
    CapacityMatrix_kthRoute_atOpticalBand_atTRXBaud_withM, <span class="keyword">...</span>
    MultiCommodityFlow, <span class="keyword">...</span>
    CandidateOpticalBand, <span class="keyword">...</span>
    CandidateTransceiver, <span class="keyword">...</span>
    CandidateTRxMod, <span class="keyword">...</span>
    MaxThroughputOptions);
<span class="comment">% Input:</span>
<span class="comment">%  - OpticalNetworks:       network topology,</span>
<span class="comment">%  - NetState:              initial network state.</span>
<span class="comment">%  - MultiCommodityFlow:    demand profile</span>
<span class="comment">%  - CandidateTransceiver:  transceiver set,</span>
<span class="comment">%  - CandidateTRxMod:       transmission mode set,</span>
<span class="comment">%  - MaxThroughputOptions:  other simulation configurations,</span>
<span class="comment">%</span>
<span class="comment">% Output:</span>
<span class="comment">%  - lightpath,</span>
<span class="comment">%  - edge spectrum usage</span>
<span class="comment">%  - other infos.</span>


<span class="comment">%</span>
<span class="comment">%</span>
<span class="comment">%       Step 3: gathering information;</span>
<span class="comment">%</span>
<span class="comment">%</span>
<span class="comment">% ==============================</span>
<span class="comment">% Calculate metric;</span>
<span class="comment">% ==============================</span>
assert(abs(resultNetworkThroughput ./ min(min( <span class="keyword">...</span>
    NetState.totalCapacityMatrix ./ NetState.normDemandMatrix)) - 1) &lt;= 1e-6<span class="keyword">...</span>
    , <span class="string">'MATLAB:main:UnExpectedResults'</span><span class="keyword">...</span>
    , <span class="string">'Not coinciding throughput definition'</span><span class="keyword">...</span>
    );
resultNoLightPaths      = LightPathSet.nSize;
resultNetworkCapacity   = sum(sum(NetState.totalCapacityMatrix));

<span class="comment">% Export network fragmentation info.</span>
bandwidthTypesSet       = unique( <span class="keyword">...</span>
    LightPathSet.nFrequencySlots(1 : resultNoLightPaths));
<span class="comment">% Note: 1 for fixed-grid; &gt;=1 for flex-grid;</span>

resultSpectrumFragRatio = calculateNetworkFragmentationRatio(<span class="keyword">...</span>
    NetState.isEdgeUseSlot, bandwidthTypesSet);

resultNetworkUtilizationRate = calculateNetworkOccupationRate(<span class="keyword">...</span>
    NetState.isEdgeUseSlot);

<span class="comment">% Average transmission capaicty per optical band.</span>
resultCapacity_ofopticalband = <span class="keyword">...</span>
    groupSum( <span class="keyword">...</span>
    nonzeros(LightPathSet.capacity) <span class="keyword">...</span>
    , nonzeros(LightPathSet.opticalBandNo)<span class="keyword">...</span>
    );
resultNoLightPaths_ofopticalband = <span class="keyword">...</span>
    groupSum( <span class="keyword">...</span>
    logical(nonzeros(LightPathSet.capacity)) <span class="keyword">...</span>
    , nonzeros(LightPathSet.opticalBandNo)<span class="keyword">...</span>
    );
</pre><pre class="codeoutput">EX4N4R0TRx50
t(ColumnGenerationHeu): 1.75823 seconods
NetworkThroughput =0.00465 Pbps, No. Transceivers =24
Spectrum fragmentation ratio = 0.908909
Network Occuptation Rate = 0.642857 
</pre><h2 id="9">main: passing parameters</h2><pre class="codeinput">info                         = containers.Map;
info(<span class="string">'RngSeed'</span>)              = rngSeed;
info(<span class="string">'NetworkID'</span>)            = networkTag;
info(<span class="string">'Gbaud'</span>)                = <span class="keyword">...</span>
    getNumeric(CandidateTransceiver, <span class="string">'GBaud'</span>);
info(<span class="string">'ModFormat'</span>)            = getChar(CandidateTRxMod, <span class="string">'name'</span>);
info(<span class="string">'Algorithms'</span>)           = algorithmName;
info(<span class="string">'Time'</span>)                 = computationTime;
info(<span class="string">'NetworkThroughput'</span>)    = resultNetworkThroughput;
info(<span class="string">'NetwokCapacity'</span>)       = resultNetworkCapacity;
info(<span class="string">'NoTransceivers'</span>)       = resultNoLightPaths;
info(<span class="string">'LimitedTransceivers'</span>)  = MaxThroughputOptions.costLimit;
<span class="keyword">for</span> iBand = 1 : nCandidateOpticalBand
    thisBand    = CandidateOpticalBand(iBand);
    info(sprintf(<span class="keyword">...</span>
        <span class="string">'%sAvgCap'</span>,thisBand.name)) <span class="keyword">...</span>
                = resultCapacity_ofopticalband(iBand) <span class="keyword">...</span>
                / resultNoLightPaths_ofopticalband(iBand);
<span class="keyword">end</span>

Astr            = [];
<span class="keyword">for</span> iiBand = 1 : nCandidateOpticalBand
    thisBand    = CandidateOpticalBand(iiBand);
    Astr        = sprintf(<span class="string">'%s%g '</span>, Astr, <span class="keyword">...</span>
        thisBand.SNRpenaltydB);
<span class="keyword">end</span>
info(<span class="string">'MultiBand'</span>) = Astr;

info(<span class="string">'SpectrumFragmentation'</span>)= resultSpectrumFragRatio;
info(<span class="string">'NetworkUtilization'</span>)   = resultNetworkUtilizationRate;
</pre><h2 id="10">main: print out information</h2><pre class="codeinput"><span class="comment">% ------------------------------</span>
<span class="comment">% Print Data as containers.map - for analyzing;</span>
[nameRow,valueRow] = printContainer(info);
printTextToFile(<span class="keyword">...</span>
    <span class="string">'Results_Table.txt'</span><span class="keyword">...</span>
    , sprintf(<span class="string">'%s\n%s'</span>, nameRow, valueRow) <span class="keyword">...</span>
    , <span class="string">'A'</span>);

<span class="comment">% ------------------------------</span>
<span class="comment">% Print LightPath to text file</span>
fileName = <span class="string">'Results_LightPathSetPerCommodity.txt'</span>;

LightPathSetPerCommodity = repmat(<span class="keyword">...</span>
    LightPath(round(NetState.nSlots/2),OpticalNetworks.nEdges) <span class="keyword">...</span>
    ,MultiCommodityFlow.nSize,1);
<span class="keyword">for</span> iPath = 1 : LightPathSet.nSize
    pNo = iPath;
    cNo = LightPathSet.nodePairNo(pNo);
    LightPathSetPerCommodity(cNo) = <span class="keyword">...</span>
        addLightPath(LightPathSetPerCommodity(cNo),LightPathSet,pNo);
<span class="keyword">end</span>
itemName = {<span class="keyword">...</span>
    <span class="string">'capacity'</span><span class="keyword">...</span>
    , <span class="string">'cost'</span><span class="keyword">...</span>
    , <span class="string">'strPath'</span><span class="keyword">...</span>
    , <span class="string">'wavelengthNo'</span><span class="keyword">...</span>
    , <span class="string">'transceiverNo'</span><span class="keyword">...</span>
    , <span class="string">'transmissionModeNo'</span><span class="keyword">...</span>
    };
printLightPathSetWithFlow(<span class="keyword">...</span>
    LightPathSetPerCommodity, <span class="keyword">...</span>
    MultiCommodityFlow, <span class="keyword">...</span>
    itemName, <span class="keyword">...</span>
    fileName, <span class="string">'w+'</span>);
</pre><h2 id="11">main: plot result</h2><pre class="codeinput">edgeSlotBlock_coloredByOpticalBandNo = <span class="keyword">...</span>
    repmat(<span class="keyword">...</span>
    NetState.opticalBandNoOfSlot'<span class="keyword">...</span>
    , OpticalNetworks.nEdges<span class="keyword">...</span>
    , 1 <span class="keyword">...</span>
    ); <span class="comment">% give opticalbandNo.</span>

isChannelUseSlots   = sparse(eye(NetState.nSlots,NetState.nSlots));
[isEdgeUseSlot]     = convertLightPath2EdgeSlot(<span class="keyword">...</span>
    LightPathSet <span class="keyword">...</span>
    , isChannelUseSlots<span class="keyword">...</span>
    );
assert(isequal(isEdgeUseSlot, NetState.isEdgeUseSlot) <span class="keyword">...</span>
    , <span class="string">'MATLAB:main:UnMatchedSize'</span> <span class="keyword">...</span>
    , <span class="string">'Check it again'</span><span class="keyword">...</span>
    );

<span class="comment">% showEdgeSpectrumGraph( ...%	Network status;</span>
<span class="comment">%     NetState.isEdgeUseSlot ...</span>
<span class="comment">%     , edgeSlotBlock_coloredByOpticalBandNo ...</span>
<span class="comment">%     , CandidateOpticalBand);</span>
<span class="comment">%</span>
<span class="comment">% pause(0.1);</span>
<span class="comment">% figure(87),</span>
<span class="comment">% clf;</span>
<span class="comment">% imagesc(logical(isEdgeUseSlot), 'CDataMapping', 'scaled');colorbar</span>
<span class="comment">% title('Spectrum Usage Graph');</span>
<span class="comment">% xlabel('Slot');</span>
<span class="comment">% ylabel('Link');</span>
<span class="comment">% hold off;</span>
</pre><h2 id="12">main: deal with function output</h2><pre class="codeinput">nOutputs = nargout;
varargout= cell(1,nOutputs);

<span class="keyword">for</span> k = 1:nOutputs
    <span class="keyword">switch</span>(k)
        <span class="keyword">case</span> 1
            varargout{1} = LightPathSet;
        <span class="keyword">case</span> 2
            varargout{2} = isEdgeUseSlot;
        <span class="keyword">case</span> 3
            varargout{3} = info;
        <span class="keyword">otherwise</span>
            error(<span class="string">'undefined'</span>);
    <span class="keyword">end</span>
<span class="keyword">end</span>
</pre><pre class="codeinput"><span class="keyword">end</span>
<span class="keyword">function</span> [networkThroughput,NewNetstate,LightPathSet] = <span class="keyword">...</span>
    ColumnGenerationHeu(Networks, NetState, <span class="keyword">...</span>
    CapacityMatrix_kthRoute_atOpticalBand_atTRXBaud_withM, <span class="keyword">...</span>
    Commodity, CandidateOpticalBand,CandidateTransponder,<span class="keyword">...</span>
    CandidateModFormat, MainOptions)
</pre><pre>       Procedure : Column Generation Approach for RWA and RWBA problems.</pre><pre>       1: Initialize wavelength configuration set Omega_init
       2: c_new &lt;-- null, Omega&lt;--Omega_init.
       3: Do
       4:      Omega &lt;== Omega and {c_new}
       5:      Solve RMP(Omega) with relaxing variables, z_c\in R_{\geq 0}
       6:      Choose a column c_new via pricing problem(s)
       7: While Reduced cost in line 6 is positive
       8: Solve RMP(Omega) with integer variables, z_c\in Z_{\geq 0}
       9: Assign a wavelength to each configuration</pre><pre>Author: cao chen (chen.cao{at}sjtu.edu.cn; chen_cao_{at}hotmail.com)
Date: Nov. 7, 2023.</pre><pre class="codeinput">assert(strcmp(MainOptions.algorithmName,<span class="string">'ColumnGenerationHeu'</span>)<span class="keyword">...</span>
    , <span class="string">'MATLAB:ColumnGenerationHeu:UnMatchedName'</span><span class="keyword">...</span>
    , <span class="string">'Algorithm name does not match'</span><span class="keyword">...</span>
    );
</pre><pre class="codeinput">NUM_COMMODITY                = Commodity.nSize;
NUM_SLOT                     = NetState.nSlots;
NUM_ROUTE                    = NetState.nRoutes;
NUM_NODE                     = Networks.nNodes;
NUM_EDGE                     = Networks.nEdges;
NUM_TRANSPONDER              = length(CandidateTransponder);
NUM_MODULATIONFORMATS        = length(CandidateModFormat);
NUM_OPTICALBAND              = length(CandidateOpticalBand);
MAXIMUM_ITERATION            = MainOptions.algorithmOption.CG_NoLoops;
vec_bandNo_ofCh              = NetState.opticalBandNoOfSlot;

vec_limitedwavelengths_onbands =  getNumeric(CandidateOpticalBand <span class="keyword">...</span>
    , <span class="string">'nFrequencySlots'</span>);
MAX_TRANSCEIVER              = MainOptions.costLimit;
</pre><h2 id="17">CG: pre-calculate ColorLessLightPathSet</h2><pre>Pre-calculate ColorLessLightPathSet _p(s,d,k,ob)_
 - This set shows all possible lightpaths within a configuration.
 - Default transceiverNo 1</pre><pre class="codeinput">MAX_LIGHTPATH_CONFIGURE      = Networks.nEdges;
<span class="comment">% since ideally, one lightpath - one hop.</span>
MAX_POSSIBILITY_PERCONFIG    = NUM_COMMODITY * NUM_ROUTE * NUM_OPTICALBAND;

assert(<span class="keyword">...</span>
    NUM_TRANSPONDER == 1 <span class="keyword">...</span>
    , <span class="string">'MATLAB:ColumnGenerationHeu:FixGrid'</span><span class="keyword">...</span>
    , <span class="string">'Cannot support two transceivers now'</span><span class="keyword">...</span>
    );
</pre><p><b>Create colorless lightpath set</b></p><pre class="codeinput">ColorlessLightPathSet = <span class="keyword">...</span>
    createColorlessLightPath(<span class="keyword">...</span>
    LightPath(MAX_POSSIBILITY_PERCONFIG, NUM_EDGE)<span class="keyword">...</span>
    , Commodity <span class="keyword">...</span>
    , NetState<span class="keyword">...</span>
    );

<span class="comment">% Assign capacity with highest modulation format</span>
<span class="keyword">for</span> iPath = 1 : ColorlessLightPathSet.nSize
    pNo = iPath;
    tb  = 1;
    [maxCapacity, targetMod] = max(<span class="keyword">...</span>
        CapacityMatrix_kthRoute_atOpticalBand_atTRXBaud_withM(<span class="keyword">...</span>
        ColorlessLightPathSet.sourceNo(pNo), <span class="keyword">...</span>
        ColorlessLightPathSet.destinationNo(pNo), <span class="keyword">...</span>
        ColorlessLightPathSet.routeNo(pNo), <span class="keyword">...</span>
        ColorlessLightPathSet.opticalBandNo(pNo), <span class="keyword">...</span>
        tb, <span class="keyword">...</span><span class="comment"> ColorlessLightPathSet.transceiverNo(pid), ...</span>
        1:NUM_MODULATIONFORMATS)<span class="keyword">...</span>
        );
    ColorlessLightPathSet.capacity(pNo) <span class="keyword">...</span>
        = maxCapacity;
    ColorlessLightPathSet.transmissionModeNo(pNo) <span class="keyword">...</span>
        = targetMod;
<span class="keyword">end</span>
</pre><h2 id="19">CG-step 1: initialize configuration</h2><pre class="codeinput">algorithmEventInitialize = tic;
<span class="keyword">switch</span> MainOptions.algorithmOption.strategyLPConfigInitial
    <span class="keyword">case</span> <span class="string">'1LP per configuration'</span>

        LP_Config_Block = zeros(MAX_LIGHTPATH_CONFIGURE, NUM_COMMODITY);
        <span class="keyword">for</span> iConfig = 1 : NUM_COMMODITY
            <span class="keyword">for</span> jPath = 1 : ColorlessLightPathSet.nSize
                <span class="keyword">if</span> iConfig == ColorlessLightPathSet.connectionNo(jPath)
                    LP_Config_Block(1, iConfig) = jPath;
                    <span class="keyword">break</span>;
                <span class="keyword">end</span>
            <span class="keyword">end</span>
        <span class="keyword">end</span>

    <span class="keyword">case</span> <span class="string">'SequentialLoadingHeu'</span>
        <span class="comment">% ==============================</span>
        <span class="comment">% Set initial algorithm options;</span>
        <span class="comment">% ==============================</span>
        nInitialConfig  = min(NUM_COMMODITY,NUM_SLOT);
        <span class="comment">% We consider the minimum number of configurations as NUM_COMMODITY,</span>
        <span class="comment">% This is for least flow between any node pairs in the network.</span>

        InitialOptions  = MaxOption(<span class="string">'SequentialLoadingHeu'</span>);
        InitialOptions  = setSolverOption(InitialOptions, <span class="keyword">...</span>
            <span class="string">'algorithmOption.algorithmName'</span>,    <span class="string">'SequentialLoadingHeu'</span>, <span class="keyword">...</span>
            <span class="string">'algorithmOption.LoadingStrategy'</span>,  <span class="string">'kSP-FF'</span>,<span class="keyword">...</span><span class="comment">'kSP-FF', 'FF-kSP'</span>
            <span class="string">'algorithmOption.TerminateStrategy'</span>,<span class="string">'All-blocking'</span>);

        InitialNetstate                 = NetState;
        InitialNetstate.isEdgeUseSlot   = zeros(NUM_EDGE, nInitialConfig);
        InitialNetstate.nSlots          = nInitialConfig;
        InitialNetstate.userParameters  = zeros(NUM_NODE, NUM_NODE);
        <span class="comment">% searching idx (for initial optimization);</span>
        <span class="comment">% ==============================</span>
        <span class="comment">% Optimize</span>
        <span class="comment">% ==============================</span>
        [~, ~,uLightPathSet] = SequentialLoadingHeu(<span class="keyword">...</span>
            Networks, <span class="keyword">...</span>
            InitialNetstate, <span class="keyword">...</span>
            CapacityMatrix_kthRoute_atOpticalBand_atTRXBaud_withM, <span class="keyword">...</span>
            Commodity, <span class="keyword">...</span>
            CandidateOpticalBand, CandidateTransponder,<span class="keyword">...</span>
            CandidateModFormat,InitialOptions);
        <span class="comment">% u means 'user';</span>
        <span class="comment">% ==============================</span>
        <span class="comment">% remove channel information, LightPaths --&gt; Config;</span>
        <span class="comment">% ==============================</span>
        LP_Config_Block             = zeros(<span class="keyword">...</span>
                                        MAX_LIGHTPATH_CONFIGURE,<span class="keyword">...</span>
                                        nInitialConfig<span class="keyword">...</span>
                                        );
        blockInitial_pNo_ofConfig   = removeWavelength(<span class="keyword">...</span>
                                        uLightPathSet <span class="keyword">...</span>
                                        , ColorlessLightPathSet <span class="keyword">...</span>
                                        );
        LP_Config_Block(1 : MAX_LIGHTPATH_CONFIGURE,1 : nInitialConfig)=<span class="keyword">...</span>
                                        blockInitial_pNo_ofConfig(<span class="keyword">...</span>
                                        1 : MAX_LIGHTPATH_CONFIGURE <span class="keyword">...</span>
                                        , 1 : nInitialConfig<span class="keyword">...</span>
                                        );
    <span class="keyword">otherwise</span>
        error(<span class="string">'non-specified StrategyLPConfigInitial'</span>);
<span class="keyword">end</span>
timeInitialize = toc(algorithmEventInitialize);
</pre><h2 id="20">CG-step 2: process new configuration and current set</h2><p>Wavelength configuration properties</p><div><ul><li>nSize: [1]</li><li>isActive: [1] * <tt>Omega</tt></li><li>no: [1] * <tt>Omega</tt></li><li>opticalBandNo: [1] * <tt>Omega</tt></li><li>nFrequencySlot: [1] * <tt>Omega</tt></li><li>nLightPath: [1] * <tt>Omega</tt></li><li>lightPathNoSet: MAX_LIGHTPATHS_PERCONFIG * <tt>Omega</tt></li><li>capacity_perCommodity: <tt>Commodity</tt> * <tt>Omega</tt></li></ul></div><pre class="codeinput">CandidateWaveConfigSet = <span class="keyword">...</span>
    WaveConfig(1e3, <span class="keyword">...</span>
    struct(<span class="keyword">...</span>
    <span class="string">'MAXIMUM_LIGHTPATHS_CONFIGURE'</span>, MAX_LIGHTPATH_CONFIGURE<span class="keyword">...</span>
    , <span class="string">'NUM_COMMODITY'</span>,              NUM_COMMODITY<span class="keyword">...</span>
    )<span class="keyword">...</span>
    );
<span class="comment">%  configure by the known lightpaths.</span>
CandidateWaveConfigSet = ConfigureParameters(CandidateWaveConfigSet, <span class="keyword">...</span>
    [1:size(LP_Config_Block,2)], <span class="keyword">...</span>
    LP_Config_Block,<span class="keyword">...</span>
    ColorlessLightPathSet);
</pre><h2 id="21">CG-step 3: Loop begins</h2><pre class="codeinput">OptionsForRMP = sdpsettings(<span class="string">'solver'</span>, <span class="string">'gurobi'</span><span class="keyword">...</span>
    , <span class="string">'verbose'</span>,            0 <span class="keyword">...</span>
    , <span class="string">'cachesolvers'</span>,       1 <span class="keyword">...</span>
    , <span class="string">'gurobi.MIPGap'</span>,      MainOptions.algorithmOption.rmp_mingap<span class="keyword">...</span>
    , <span class="string">'debug'</span>,              0 <span class="keyword">...</span>
    , <span class="string">'gurobi.TimeLimit'</span>,   MainOptions.algorithmOption.rmp_TimeLimit<span class="keyword">...</span>
    );

<span class="comment">% - Simulation: ILP option</span>
OptionPricing.OptimalityTol = MainOptions.algorithmOption.pricing_optimality_tol;
OptionPricing.MIPgap        = MainOptions.algorithmOption.pricing_mingap;



algorithmEventCGLoop = tic;

<span class="comment">% ==============================</span>
<span class="comment">% Create plot handles</span>
<span class="comment">% ==============================</span>
objRMP_ofiter     = NaN(MAXIMUM_ITERATION, 1);
objPricing_ofiter = NaN(MAXIMUM_ITERATION, 1);
figure(1);
hRMP = plot(objRMP_ofiter,<span class="string">'YDataSource'</span>,<span class="string">'objRMP_ofiter'</span>);
xlabel(<span class="string">'# iterations'</span>);
ylabel(<span class="string">'Max. Throughput [Gbps]'</span>);
title(<span class="string">'Varation of Max. Throughput [Gbit/s]'</span>);

figure(2); hPricing = plot(objPricing_ofiter,<span class="string">'YDataSource'</span>,<span class="string">'objPricing_ofiter'</span>);
xlabel(<span class="string">'# iterations'</span>);
ylabel(<span class="string">'Reduced cost (in Pricing Problem)'</span>);
title(<span class="string">'Varation of Reduced Cost'</span>);

<span class="comment">%=================================</span>
<span class="comment">% Create empty configuration</span>
<span class="comment">%=================================</span>
ConfigNew               = [];
Capacity_oncommodity    = [];
idxBestPricing          = [];
<span class="keyword">for</span> iIteration = 1 : MAXIMUM_ITERATION
    <span class="comment">%=================================</span>
    <span class="comment">%     Add a new configuration;</span>
    <span class="comment">%=================================</span>
    curNo                  = CandidateWaveConfigSet.nSize;
    CandidateWaveConfigSet = ConfigureParameters(CandidateWaveConfigSet, <span class="keyword">...</span>
                                                    [curNo+1], <span class="keyword">...</span>
                                                    ConfigNew,<span class="keyword">...</span>
                                                    ColorlessLightPathSet<span class="keyword">...</span>
                                                    );
    <span class="comment">%=================================</span>
    <span class="comment">%          Restricted Master Problem (printing reduced cost).</span>
    <span class="comment">%=================================</span>
    <span class="comment">% fprintf('At iteration %d ==============================\n'...</span>
    <span class="comment">%           , count_iteration);</span>
    <span class="comment">% fprintf('**(Restricted Master Problem)\n');</span>
    [obj_RestrictedMasterProblem_LP, <span class="keyword">...</span>
        ~, <span class="keyword">...</span>
        dual_commodity, <span class="keyword">...</span>
        dual_onLimitedTransceiver, <span class="keyword">...</span>
        dual_onLimitedWavelength, <span class="keyword">...</span>
        ReducedCost_perConfig] = solveRMP( <span class="keyword">...</span>
                                    CandidateWaveConfigSet<span class="keyword">...</span>
                                    , Commodity <span class="keyword">...</span>
                                    , vec_limitedwavelengths_onbands<span class="keyword">...</span>
                                    , MAX_TRANSCEIVER<span class="keyword">...</span>
                                    , OptionsForRMP<span class="keyword">...</span>
                                    );

    DualVariables = struct(<span class="keyword">...</span>
        <span class="string">'dual_commodity'</span>,            dual_commodity, <span class="keyword">...</span>
        <span class="string">'dual_onLimitedTransceiver'</span>, dual_onLimitedTransceiver, <span class="keyword">...</span>
        <span class="string">'dual_onLimitedWavelength'</span>,  dual_onLimitedWavelength<span class="keyword">...</span>
        );

    <span class="comment">% ==============================</span>
    <span class="comment">%  Pricing Problem</span>
    <span class="comment">% :: Maximum Weight Independent Set Problem.</span>
    <span class="comment">% ==============================</span>
    <span class="comment">%     fprintf('**(Pricing problem)==============================\n');</span>
    OBJ_REDUCED_COST = zeros(NUM_OPTICALBAND, 1);
    ConfigNewPricing = zeros(MAX_LIGHTPATH_CONFIGURE, NUM_OPTICALBAND);
    <span class="keyword">for</span> b = 1 : NUM_OPTICALBAND
        <span class="comment">% ==============================</span>
        <span class="comment">% Pricing by ILP</span>
        <span class="comment">% ==============================</span>
        <span class="comment">% [ConfigNew, obj_PricingProblem, NoLPsConfigNew] = ILP_ForPricingMultiBand( ...</span>
        <span class="comment">%     OptionPricing...</span>
        <span class="comment">%     ,ColorlessLightPathSet...</span>
        <span class="comment">%     ,b... % choose LightPaths on ob-th optical band.</span>
        <span class="comment">%     ,Commodity...</span>
        <span class="comment">%     ,DualVariables ...</span>
        <span class="comment">%     ,Networks...</span>
        <span class="comment">%     );</span>
        <span class="comment">% ==============================</span>
        <span class="comment">% Pricing by heuristics</span>
        <span class="comment">% ==============================</span>
        [ConfigNew, obj_PricingProblem, NoLPsConfigNew] = <span class="keyword">...</span>
            HEU1_ForPricingMultiBand( <span class="keyword">...</span>
            OptionPricing, <span class="keyword">...</span>
            ColorlessLightPathSet, b, <span class="keyword">...</span>
            Commodity, <span class="keyword">...</span>
            DualVariables<span class="keyword">...</span>
            );
        OBJ_REDUCED_COST(b) = obj_PricingProblem;
        ConfigNewPricing(1 : NoLPsConfigNew, b) = <span class="keyword">...</span>
                                    ConfigNew(1 : NoLPsConfigNew);
    <span class="keyword">end</span>
    <span class="comment">% ==============================</span>
    <span class="comment">%     Find the most promising configuration;</span>
    <span class="comment">% - idxBestPricing     : optical band no.</span>
    <span class="comment">% - ConfigNew          : lightPaths in this configuration;</span>
    <span class="comment">% ==============================</span>
    [~,idxBestPricing] = max(OBJ_REDUCED_COST);
    <span class="keyword">if</span> OBJ_REDUCED_COST(idxBestPricing)&lt;=1e-4
        fprintf(<span class="string">'iteration ends with no new optimal columns\n'</span>);
        <span class="keyword">break</span>;
    <span class="keyword">end</span>
    ConfigNew = ConfigNewPricing(1 : MAX_LIGHTPATH_CONFIGURE,idxBestPricing);

    <span class="comment">% ==============================</span>
    <span class="comment">%     Plot convergence performance</span>
    objRMP_ofiter(iIteration)    = obj_RestrictedMasterProblem_LP;
    objPricing_ofiter(iIteration)= OBJ_REDUCED_COST(idxBestPricing);
    refreshdata(hRMP,<span class="string">'caller'</span>); drawnow;
    refreshdata(hPricing,<span class="string">'caller'</span>); drawnow;
    pause(.05);
    <span class="comment">% ==============================</span>
<span class="keyword">end</span>

timeCGLoop = toc(algorithmEventCGLoop);
</pre><pre class="codeoutput">iteration ends with no new optimal columns
</pre><img vspace="5" hspace="5" src="main_01.png" style="width:560px;height:420px;" alt=""> <img vspace="5" hspace="5" src="main_02.png" style="width:560px;height:420px;" alt=""> <h2 id="22">CG-step 4: RMP with integer constraints</h2><pre>Simulation: ILP option for RMP_INT</pre><pre class="codeinput">OptionRMPINT.OptimalityTol = MainOptions.algorithmOption.RMPINTOptimalityTol;
OptionRMPINT.MIPgap        = MainOptions.algorithmOption.RMPINTMIPgap;
OptionRMPINT.TimeLimit     = MainOptions.algorithmOption.RMPINTTimeLimit;
eventRMPINT                = tic;
[obj_RestrictedMasterProblem, rep_Config] = solveRMP_INT( <span class="keyword">...</span>
    OptionRMPINT <span class="keyword">...</span>
    , CandidateWaveConfigSet<span class="keyword">...</span>
    , Commodity <span class="keyword">...</span>
    , vec_limitedwavelengths_onbands <span class="keyword">...</span>
    , MAX_TRANSCEIVER<span class="keyword">...</span>
    );

networkThroughput  = obj_RestrictedMasterProblem;
rep_Config         = round(rep_Config); <span class="comment">% float if large solution gap</span>

timeRMPINT          = toc(eventRMPINT);
</pre><pre class="codeoutput">Academic license - for non-commercial use only
Gurobi Optimizer version 9.0.1 build v9.0.1rc0 (win64)
Optimize a model with 12 rows, 7 columns and 33 nonzeros
Model fingerprint: 0x236a17ae
Variable types: 1 continuous, 6 integer (0 binary)
Coefficient statistics:
  Matrix range     [3e-01, 6e+02]
  Objective range  [1e+00, 1e+00]
  Bounds range     [0e+00, 0e+00]
  RHS range        [2e+00, 1e+06]
Found heuristic solution: objective 0.0000000
Presolve removed 9 rows and 4 columns
Presolve time: 0.00s
Presolved: 3 rows, 3 columns, 7 nonzeros
Found heuristic solution: objective -1185.000000
Variable types: 0 continuous, 3 integer (0 binary)

Root relaxation: objective -5.055401e+03, 3 iterations, 0.00 seconds

    Nodes    |    Current Node    |     Objective Bounds      |     Work
 Expl Unexpl |  Obj  Depth IntInf | Incumbent    BestBd   Gap | It/Node Time

     0     0 -5055.4011    0    3 -1185.0000 -5055.4011   327%     -    0s
H    0     0                    -4200.000000 -5055.4011  20.4%     -    0s
H    0     0                    -4650.000000 -5055.4011  8.72%     -    0s
     0     0 -5055.4011    0    3 -4650.0000 -5055.4011  8.72%     -    0s

Explored 1 nodes (3 simplex iterations) in 0.10 seconds
Thread count was 4 (of 4 available processors)

Solution count 4: -4650 -4200 -1185 0 
No other solutions better than -4650

Optimal solution found (tolerance 1.00e-02)
Best objective -4.650000000000e+03, best bound -4.650000000000e+03, gap 0.0000%
Solver thinks it is feasible
Obj = 4650
No. Times = [2,0,4,0,0,2]
opticalBandNo = [1,1,1,2,2,2]
No. Transceivers = sum([18,6]) = [24]/[1000000]
No. Wavelengths  = [6,2]/[6,2]
</pre><h2 id="23">CG-step 5: configure wavelength</h2><p><b>Sort configurations</b></p><pre class="codeinput">PackOption = struct( <span class="keyword">...</span>
    <span class="string">'isGroup'</span>,      true, <span class="keyword">...</span>
    <span class="string">'direction'</span>,    <span class="string">'descend'</span>, <span class="keyword">...</span><span class="comment">'descend', 'ascend'</span>
    <span class="string">'basis'</span>,        <span class="string">'numberOfRepetitions'</span><span class="keyword">...</span>
    <span class="keyword">...</span><span class="comment">'numberOfRepetitions',</span>
    <span class="keyword">...</span><span class="comment">'numberOfFrequencySlots',</span>
    <span class="keyword">...</span><span class="comment">'numberOfLightPaths',</span>
    <span class="keyword">...</span><span class="comment">'random'</span>
    );

[vec_ColoredConfigID_ofCh] = packConfiguration(CandidateWaveConfigSet, <span class="keyword">...</span>
    rep_Config, PackOption);

<span class="comment">% ==============================</span>
<span class="comment">% Processing lightpath;</span>
<span class="comment">% ==============================</span>
LP_Config_Block = CandidateWaveConfigSet.lightPathNoSet(1:MAX_LIGHTPATH_CONFIGURE,<span class="keyword">...</span>
    1:CandidateWaveConfigSet.nSize);
<span class="comment">% add color : configuration to lightpath;</span>
LightPathSet    = addWavelength(<span class="keyword">...</span>
    LP_Config_Block<span class="keyword">...</span>
    , rep_Config<span class="keyword">...</span>
    , vec_ColoredConfigID_ofCh<span class="keyword">...</span>
    , ColorlessLightPathSet<span class="keyword">...</span>
    );
<span class="keyword">for</span> iiPath = 1 : LightPathSet.nSize
    pNo         = iiPath;
    wChannel    = LightPathSet.wavelengthNo(pNo);

    LightPathSet.opticalBandNo(pNo) = vec_bandNo_ofCh(wChannel);
<span class="keyword">end</span>
Z_Ch_useslots   = eye(NUM_SLOT,NUM_SLOT);
[edgeSlotBlock] = convertLightPath2EdgeSlot(<span class="keyword">...</span>
    LightPathSet <span class="keyword">...</span>
    , Z_Ch_useslots);
</pre><h2 id="24">CG-step 6: data post-processing</h2><p>============================== Obtain neccesary parameter settings; ==============================</p><pre class="codeinput">nConfigs        = CandidateWaveConfigSet.nSize;
nPath_perConfig = double(CandidateWaveConfigSet.nLightPath(1 : nConfigs));
assert(<span class="keyword">...</span>
    nPath_perConfig(:)'*rep_Config(:) == LightPathSet.nSize<span class="keyword">...</span>
    , <span class="string">'MATLAB:ColumnGenerationHeu:UnMachedSize'</span><span class="keyword">...</span>
    , <span class="string">'They must be same'</span><span class="keyword">...</span>
    );
assert(<span class="keyword">...</span>
    numel(rep_Config) == nConfigs<span class="keyword">...</span>
    , <span class="string">'MATLAB:ColumnGenerationHeu:UnExpectedValues'</span><span class="keyword">...</span>
    , <span class="string">'They must be in the same size'</span><span class="keyword">...</span>
    );
assert(<span class="keyword">...</span>
    sum(rep_Config(:)) &lt;= sum(vec_limitedwavelengths_onbands)<span class="keyword">...</span>
    , <span class="string">'MATLAB:ColumnGenerationHeu:UnExpectedValues'</span><span class="keyword">...</span>
    , <span class="string">'Wrong wavelength'</span><span class="keyword">...</span>
    );

vec_bandNo_onconfigc = CandidateWaveConfigSet.opticalBandNo(1:nConfigs);

capacityMatrix_commodityi_onconfigc = <span class="keyword">...</span>
    CandidateWaveConfigSet.capacity_perCommodity(<span class="keyword">...</span>
        1 : NUM_COMMODITY, <span class="keyword">...</span>
        1 : nConfigs<span class="keyword">...</span>
    );

<span class="comment">%=================================</span>
<span class="comment">% Processing and passing parameters.</span>
<span class="comment">%=================================</span>
<span class="comment">% no. LPs per optical band</span>
vec_nLPs_ofband = groupSum(<span class="keyword">...</span>
    nPath_perConfig(:).*rep_Config(:)<span class="keyword">...</span>
    , vec_bandNo_onconfigc<span class="keyword">...</span>
    );
<span class="comment">% total LPs' capacity per optical band</span>
vec_LPCap_ofbands = groupSum(<span class="keyword">...</span>
    sum(capacityMatrix_commodityi_onconfigc,1)'.*rep_Config(:)<span class="keyword">...</span>
    , vec_bandNo_onconfigc<span class="keyword">...</span>
    );

<span class="comment">% ==============================</span>
<span class="comment">% Update state</span>
<span class="comment">% ==============================</span>

NewNetstate        = NetState;
connectionCapaicty = zeros(NUM_NODE,NUM_NODE);
<span class="keyword">for</span> iCommodity = 1 : NUM_COMMODITY
    src                         = Commodity.sourceNo(iCommodity);
    dst                         = Commodity.destinationNo(iCommodity);
    connectionCapaicty(src,dst) = <span class="keyword">...</span>
        capacityMatrix_commodityi_onconfigc(iCommodity, 1 : nConfigs) <span class="keyword">...</span>
        * rep_Config;
<span class="keyword">end</span>
NewNetstate.totalCapacityMatrix = connectionCapaicty;

UserParameters = struct(<span class="keyword">...</span>
    <span class="string">'obj_RMP_LP'</span>,   obj_RestrictedMasterProblem_LP, <span class="keyword">...</span>
    <span class="string">'NoConfigs'</span>,    nConfigs, <span class="keyword">...</span>
    <span class="string">'tCG_ofHeuInit'</span>,timeInitialize, <span class="keyword">...</span>
    <span class="string">'tCG_iteration'</span>,timeCGLoop, <span class="keyword">...</span>
    <span class="string">'tCG_INT'</span>,      timeRMPINT<span class="keyword">...</span>
    );
NewNetstate.userParameters = UserParameters;


NewNetstate.isEdgeUseSlot = edgeSlotBlock;
</pre><p><b>Print</b></p><div><ul><li>print configurations to text file;</li><li>print selected information to text file;</li></ul></div><pre class="codeinput">fprintf(<span class="string">'Average LP''s on Optical Bands = [%s] \n'</span>, <span class="keyword">...</span>
    printArray(vec_LPCap_ofbands ./ vec_nLPs_ofband));
fprintf(<span class="string">'Column Generation (init.= %g, iter. = %g seconds, INT = %g seconds). \n'</span>,<span class="keyword">...</span>
    timeInitialize, timeCGLoop, timeRMPINT);

<span class="comment">% print configurations to text file;</span>
fileName = <span class="string">'Results_Configuration.txt'</span>;
headInfo = sprintf(<span class="keyword">...</span>
    <span class="string">'Objective: maximum network throughput = %g, no. lightpaths=%d, no. configurations=%d (no. configuration types= %d)\n'</span>, <span class="keyword">...</span>
    obj_RestrictedMasterProblem, <span class="keyword">...</span>
    LightPathSet.nSize, <span class="keyword">...</span>
    CandidateWaveConfigSet.nSize, <span class="keyword">...</span>
    length(nonzeros(rep_Config)));
printTextToFile(fileName, headInfo, <span class="string">'w+'</span>);
printConfiguration(<span class="keyword">...</span>
    CandidateWaveConfigSet<span class="keyword">...</span>
    , fileName <span class="keyword">...</span>
    , rep_Config <span class="keyword">...</span>
    , ColorlessLightPathSet);

<span class="comment">% ==============================</span>
<span class="comment">% print selected information to text.</span>
<span class="comment">% ==============================</span>



CG_DataRow                      = containers.Map;
CG_DataRow(<span class="string">'InitialAlgorithm'</span>)  = <span class="keyword">...</span>
    MainOptions.algorithmOption.strategyLPConfigInitial;
CG_DataRow(<span class="string">'NetworkTESTID'</span>)     = Networks.tag;
CG_DataRow(<span class="string">'NetworkThroughput'</span>) = networkThroughput;
CG_DataRow(<span class="string">'RngSeed'</span>)           = MainOptions.rngSeed;
CG_DataRow(<span class="string">'obj_RMP_LP'</span>)        = NewNetstate.userParameters.obj_RMP_LP;
CG_DataRow(<span class="string">'NoConfigs'</span>)         = NewNetstate.userParameters.NoConfigs;
CG_DataRow(<span class="string">'tCG_ofHeuInit'</span>)     = num2str(NewNetstate.userParameters.tCG_ofHeuInit);
CG_DataRow(<span class="string">'tCG_iteration'</span>)     = num2str(NewNetstate.userParameters.tCG_iteration);
CG_DataRow(<span class="string">'tCG_INT'</span>)           = num2str(NewNetstate.userParameters.tCG_INT);

[nameRow, valueRow]             = printContainer(CG_DataRow);

printTextToFile(<span class="keyword">...</span>
    <span class="string">'Results_TableCG.txt'</span><span class="keyword">...</span>
    , sprintf(<span class="string">'%s\n%s'</span>, nameRow, valueRow)<span class="keyword">...</span>
    , <span class="string">'A'</span>); <span class="comment">% 'A' is important for parallel computation;</span>
</pre><pre class="codeoutput">Average LP's on Optical Bands = [207.222,208.333] 
Column Generation (init.= 0.0796057, iter. = 0.870922 seconds, INT = 0.175578 seconds). 
</pre><pre class="codeinput"><span class="keyword">end</span>

<span class="keyword">function</span> [NetworkThroughput, NewNetState, LightPathSet, ComputationTime]=<span class="keyword">...</span>
    MaxThroughput(<span class="keyword">...</span>
    func<span class="keyword">...</span>
    , OpticalNetworks <span class="keyword">...</span>
    , NetState <span class="keyword">...</span>
    , capacityMatrix_kthRoute_atOpticalBand_atTRXBaud_withM <span class="keyword">...</span>
    , Commodity <span class="keyword">...</span>
    , CandidateOpticalBand <span class="keyword">...</span>
    , CandidateTransponder <span class="keyword">...</span>
    , CandidateModFormat <span class="keyword">...</span>
    , Options<span class="keyword">...</span>
    )

<span class="comment">% Check number of input arguments</span>
<span class="keyword">try</span>
    narginchk(9,9);
<span class="keyword">catch</span> ME
    error(ME.message);
<span class="keyword">end</span>

<span class="keyword">if</span>(iscell(func))
    fun = func{1};
<span class="keyword">elseif</span>(isa(func,<span class="string">'char'</span>)) <span class="comment">% for string;</span>
    fun = str2func(func);
<span class="keyword">else</span>
    fun = func;
<span class="keyword">end</span>

<span class="comment">% capacity scaling;</span>
scalingFactor = Options.capacityScalingFactor;
<span class="comment">% ------------------------------</span>
<span class="comment">% scalingFactor = 1e-3*0+1; % #demo: scaling if neccessary;</span>
<span class="comment">% ------------------------------</span>
capacityMatrix_kthRoute_atOpticalBand_atTRXBaud_withM = <span class="keyword">...</span>
    capacityMatrix_kthRoute_atOpticalBand_atTRXBaud_withM  <span class="keyword">...</span>
    .* scalingFactor;

Alg = tic;
<span class="keyword">switch</span> Options.algorithmName
    <span class="keyword">case</span> <span class="string">'ColumnGenerationHeu'</span>
        [NetworkThroughput,NewNetState,LightPathSet] = fun(<span class="keyword">...</span>
            OpticalNetworks, NetState, <span class="keyword">...</span>
            capacityMatrix_kthRoute_atOpticalBand_atTRXBaud_withM, <span class="keyword">...</span>
            Commodity, <span class="keyword">...</span>
            CandidateOpticalBand,CandidateTransponder,CandidateModFormat,Options);
        NewNetState.userParameters.obj_RMP_LP= <span class="keyword">...</span><span class="comment">% special for user_parameters.</span>
            NewNetState.userParameters.obj_RMP_LP*1/scalingFactor;
    <span class="keyword">case</span> <span class="string">'SequentialLoadingHeu'</span>
        NetState.userParameters = zeros(OpticalNetworks.nNodes,<span class="keyword">...</span>
            OpticalNetworks.nNodes); <span class="comment">% searching idx &lt;= 0 ;</span>
        [NetworkThroughput,NewNetState,LightPathSet] = fun(<span class="keyword">...</span>
            OpticalNetworks, NetState, <span class="keyword">...</span>
            capacityMatrix_kthRoute_atOpticalBand_atTRXBaud_withM, <span class="keyword">...</span>
            Commodity, <span class="keyword">...</span>
            CandidateOpticalBand,CandidateTransponder,CandidateModFormat,Options);
    <span class="keyword">case</span> <span class="string">'ILPmodel'</span>
        [NetworkThroughput,NewNetState,LightPathSet] = fun(<span class="keyword">...</span>
            OpticalNetworks, NetState, <span class="keyword">...</span>
            capacityMatrix_kthRoute_atOpticalBand_atTRXBaud_withM, <span class="keyword">...</span>
            Commodity, <span class="keyword">...</span>
            CandidateOpticalBand,CandidateTransponder,CandidateModFormat,Options);
    <span class="keyword">otherwise</span>
        error(<span class="string">'Not defined'</span>);
<span class="keyword">end</span>
ComputationTime         = toc(Alg);

<span class="comment">% capacity re-scaling for all parameters related to the capacity;</span>
NetworkThroughput       = NetworkThroughput * 1./scalingFactor;
NewNetState.totalCapacityMatrix = <span class="keyword">...</span>
    NewNetState.totalCapacityMatrix * 1/scalingFactor;
LightPathSet.capacity   = LightPathSet.capacity * 1/scalingFactor;


<span class="comment">% Output basic information (results, run time, etc.)</span>
thisAlgorithmName       = Options.algorithmOption.algorithmName;
<span class="keyword">if</span>(strcmp(Options.algorithmName, <span class="string">'SequentialLoadingHeu'</span>))
    thisAlgorithmName   = sprintf(<span class="string">'%s'</span>, <span class="keyword">...</span>
        Options.algorithmOption.LoadingStrategy);
<span class="keyword">end</span>
fprintf(<span class="string">'t(%s): %g seconods\n'</span>, thisAlgorithmName, ComputationTime);
fprintf(<span class="string">'NetworkThroughput =%g Pbps, No. Transceivers =%d\n'</span>, <span class="keyword">...</span>
    1e-6*NetworkThroughput, LightPathSet.nSize);

<span class="keyword">end</span>


<span class="keyword">function</span> [networkThroughput, NewNetState, LightPathSet] = <span class="keyword">...</span>
    ILPmodel(<span class="keyword">...</span>
    Networks <span class="keyword">...</span>
    , Netstate <span class="keyword">...</span>
    , capacityMatrix_kthRoute_atOpticalBand_atTRXBaud_withM <span class="keyword">...</span>
    , Commodity <span class="keyword">...</span>
    , CandidateOpticalBand <span class="keyword">...</span>
    , CandidateTransceiver <span class="keyword">...</span>
    , CandidateModFormat <span class="keyword">...</span>
    , MainOptions<span class="keyword">...</span>
    )
</pre><pre class="codeinput"><span class="comment">% Check Algorithm's name;</span>
assert(strcmp(MainOptions.algorithmName, <span class="string">'ILPmodel'</span>) <span class="keyword">...</span>
    , <span class="string">'Algorithm name does not match'</span>);


<span class="comment">% ==============================</span>
<span class="comment">% Fast parameter extraction</span>
<span class="comment">% ==============================</span>
NUM_NODE                     = Networks.nNodes;
NUM_EDGE                     = Networks.nEdges;
NUM_ROUTE                    = Netstate.nRoutes;
NUM_CHANNEL                  = Netstate.nSlots;
NUM_SLOT                     = Netstate.nSlots;

EXCLUDE_IDDENTICALPAIR       = Netstate.STATUS_TRUE_CONNECTIONS;
normalizedDemand             = Netstate.normDemandMatrix;
bin_sdk_atl                  = Netstate.isPathOnsdkUseLink;
vec_opticalBandNo_ofCh       = Netstate.opticalBandNoOfSlot;

NUM_TRANSPONDER              = length(CandidateTransceiver);
NUM_MODULATIONFORMAT         = length(CandidateModFormat);
NUM_COMMODITY                = Commodity.nSize;
limitedTransceivers          = MainOptions.costLimit;
</pre><h2 id="28">ILP-initialize parameters</h2><pre>Lightpath capacity conversion</pre><pre class="codeinput">capacityMatrix_kthRoute_atCh = zeros(NUM_NODE, NUM_NODE, NUM_ROUTE, NUM_CHANNEL);
targetMod_kthRoute_atCh      = zeros(NUM_NODE, NUM_NODE, NUM_ROUTE, NUM_CHANNEL);
<span class="keyword">for</span> ch = 1:NUM_CHANNEL
    idx_ob      = vec_opticalBandNo_ofCh(ch);
    [cap,cM]    = max(max( <span class="keyword">...</span>
        capacityMatrix_kthRoute_atOpticalBand_atTRXBaud_withM(<span class="keyword">...</span>
        1 : NUM_NODE<span class="keyword">...</span>
        , 1 : NUM_NODE <span class="keyword">...</span>
        , 1 : NUM_ROUTE<span class="keyword">...</span>
        , idx_ob <span class="keyword">...</span>
        , 1 : NUM_TRANSPONDER<span class="keyword">...</span>
        , 1 : NUM_MODULATIONFORMAT<span class="keyword">...</span>
        )<span class="keyword">...</span>
        ,[],5)<span class="keyword">...</span>
        ,[],6);
    targetMod_kthRoute_atCh(1:NUM_NODE,1:NUM_NODE,1:NUM_ROUTE,ch) = cM;
    capacityMatrix_kthRoute_atCh(1:NUM_NODE,1:NUM_NODE,1:NUM_ROUTE,ch) = cap;
<span class="keyword">end</span>
</pre><h2 id="29">ILP-step1: define variable</h2><pre class="codeinput">eventILP                = tic;

var_bin_sdk_atCh        = binvar(NUM_NODE,NUM_NODE,NUM_ROUTE,NUM_CHANNEL,<span class="string">'full'</span>);
var_Throughput          = sdpvar(1,1);
var_Throughput_matrix   = sdpvar(NUM_NODE,NUM_NODE,<span class="string">'full'</span>);
</pre><h2 id="30">ILP-step2: add constraints</h2><pre class="codeinput">Constraints = [];
<span class="comment">% Limited transceivers;</span>
Constraints = [Constraints, <span class="keyword">...</span>
    (sum(sum(sum(sum(var_bin_sdk_atCh))))&lt;=limitedTransceivers):<span class="string">'Limited Transceivers'</span>];

<span class="comment">% Constraints (1): for maximum capacity; this is easier to understand (may be not very fast)</span>
var_Capacity_Matrix = sum(sum(sum( <span class="keyword">...</span>
    capacityMatrix_kthRoute_atCh(:,:,1:NUM_ROUTE,1:NUM_CHANNEL).* var_bin_sdk_atCh(:,:,1:NUM_ROUTE,1:NUM_CHANNEL), <span class="keyword">...</span>
    5),4),3);
Constraints = [Constraints,<span class="keyword">...</span>
    (var_Throughput_matrix(EXCLUDE_IDDENTICALPAIR)&lt;=var_Capacity_Matrix(EXCLUDE_IDDENTICALPAIR)):[<span class="string">'Throughput definition'</span>]];
Constraints = [Constraints,<span class="keyword">...</span><span class="comment"> % Bug Fixed (this expression is better).</span>
    (var_Throughput.*normalizedDemand(EXCLUDE_IDDENTICALPAIR)&lt;=var_Throughput_matrix(EXCLUDE_IDDENTICALPAIR)):<span class="string">'Total throughput'</span>];



<span class="comment">% Constraints (2) one link no wavelength sharing;</span>
logical_sum_Matrix_ofK_atCh_onl = repmat(EXCLUDE_IDDENTICALPAIR,1,1,NUM_ROUTE,NUM_CHANNEL,NUM_EDGE) <span class="keyword">...</span>
    .* permute(repmat(bin_sdk_atl,1,1,1,1,NUM_CHANNEL),[1,2,3,5,4]);
var_SingleLink_SingSlot = permute(sum(sum(sum( <span class="keyword">...</span>
    repmat(var_bin_sdk_atCh(1:NUM_NODE,1:NUM_NODE,1:NUM_ROUTE,1:NUM_CHANNEL),1,1,1,1,NUM_EDGE) <span class="keyword">...</span>
    .*logical_sum_Matrix_ofK_atCh_onl(1:NUM_NODE,1:NUM_NODE,1:NUM_ROUTE,1:NUM_CHANNEL,1:NUM_EDGE),<span class="keyword">...</span>
    1),<span class="keyword">...</span>
    2),<span class="keyword">...</span>
    3),<span class="keyword">...</span>
    [5,4,1,2,3]);
Constraints = [Constraints,<span class="keyword">...</span>
    var_SingleLink_SingSlot &lt;=ones(NUM_EDGE,NUM_SLOT)];


<span class="comment">% % ==============================</span>
<span class="comment">% % Temporaily for RWBA (w1=w2=w3=w4=w5, w6, w7, w8) #demo</span>
<span class="comment">% % ==============================</span>
<span class="comment">% Constraints = [Constraints,...</span>
<span class="comment">%     var_delta_sdk_atCh(1:nNodes,1:nNodes,1:NUM_ROUTES, 1) == var_delta_sdk_atCh(1:nNodes,1:nNodes,1:NUM_ROUTES, 2)];</span>
<span class="comment">% Constraints = [Constraints,...</span>
<span class="comment">%     var_delta_sdk_atCh(1:nNodes,1:nNodes,1:NUM_ROUTES, 1) == var_delta_sdk_atCh(1:nNodes,1:nNodes,1:NUM_ROUTES, 3)];</span>
<span class="comment">% Constraints = [Constraints,...</span>
<span class="comment">%     var_delta_sdk_atCh(1:nNodes,1:nNodes,1:NUM_ROUTES, 1) == var_delta_sdk_atCh(1:nNodes,1:nNodes,1:NUM_ROUTES, 4)];</span>
<span class="comment">% Constraints = [Constraints,...</span>
<span class="comment">%     var_delta_sdk_atCh(1:nNodes,1:nNodes,1:NUM_ROUTES, 1) == var_delta_sdk_atCh(1:nNodes,1:nNodes,1:NUM_ROUTES, 5)];</span>
<span class="comment">%</span>
<span class="comment">% % ==============================</span>
<span class="comment">% % Temporaily for RWA; (w1=w2=w3=w4, w5=w6=w7, w8) #demo</span>
<span class="comment">% % ==============================</span>
<span class="comment">% Constraints = [Constraints,...</span>
<span class="comment">%     var_delta_sdk_atCh(1:nNodes,1:nNodes,1:NUM_ROUTES, 1) == var_delta_sdk_atCh(1:nNodes,1:nNodes,1:NUM_ROUTES, 2)];</span>
<span class="comment">% Constraints = [Constraints,...</span>
<span class="comment">%     var_delta_sdk_atCh(1:nNodes,1:nNodes,1:NUM_ROUTES, 1) == var_delta_sdk_atCh(1:nNodes,1:nNodes,1:NUM_ROUTES, 3)];</span>
<span class="comment">% Constraints = [Constraints,...</span>
<span class="comment">%     var_delta_sdk_atCh(1:nNodes,1:nNodes,1:NUM_ROUTES, 1) == var_delta_sdk_atCh(1:nNodes,1:nNodes,1:NUM_ROUTES, 4)];</span>
<span class="comment">%</span>
<span class="comment">% Constraints = [Constraints,...</span>
<span class="comment">%     var_delta_sdk_atCh(1:nNodes,1:nNodes,1:NUM_ROUTES, 5) == var_delta_sdk_atCh(1:nNodes,1:nNodes,1:NUM_ROUTES, 6)];</span>
<span class="comment">% Constraints = [Constraints,...</span>
<span class="comment">%     var_delta_sdk_atCh(1:nNodes,1:nNodes,1:NUM_ROUTES, 5) == var_delta_sdk_atCh(1:nNodes,1:nNodes,1:NUM_ROUTES, 7)];</span>
</pre><h2 id="31">ILP-step3: set objective</h2><pre class="codeinput">Objective = var_Throughput;
</pre><h2 id="32">ILP-step4: solve problem</h2><pre class="codeinput">options = sdpsettings(<span class="string">'solver'</span>, <span class="string">'gurobi'</span><span class="keyword">...</span>
    , <span class="string">'verbose'</span>,                2 <span class="keyword">...</span>
    , <span class="string">'cachesolvers'</span>,           1 <span class="keyword">...</span>
    , <span class="string">'gurobi.FeasibilityTol'</span>,  MainOptions.algorithmOption.ILP_FeasibilityTol<span class="keyword">...</span>
    , <span class="string">'gurobi.OptimalityTol'</span>,   MainOptions.algorithmOption.ILP_OptimalityTol<span class="keyword">...</span>
    , <span class="string">'gurobi.MIPGap'</span>,          MainOptions.algorithmOption.ILP_MIPGap<span class="keyword">...</span>
    );
options.gurobi.TimeLimit = MainOptions.algorithmOption.ILP_TimeLimit;

diagnostics = optimize(Constraints,-Objective,options);

<span class="keyword">if</span>      diagnostics.problem == 0
    disp(<span class="string">'Solver thinks it is feasible'</span>)
<span class="keyword">elseif</span>  diagnostics.problem == 1
    disp(<span class="string">'Solver thinks it is infeasible'</span>)
<span class="keyword">elseif</span>  diagnostics.problem == -3
    disp(<span class="string">'Solver not found, so of course x is not optimized'</span>)
<span class="keyword">else</span>
    disp(<span class="string">'Something else happened'</span>)
<span class="keyword">end</span>

t_ILP = toc(eventILP);
</pre><p><b>Passing variables into workspace</b></p><pre class="codeinput">delta_sdk_atCh           = round(value(var_bin_sdk_atCh)); <span class="comment">% avoid float value returned by Gurobi;</span>
delta_sdk_atCh           = removeNaN(delta_sdk_atCh);

networkThroughput        = value(var_Throughput);
assert(networkThroughput&gt;=1e-4 <span class="keyword">...</span>
    , <span class="string">'No throughput. Something might be wrong, please check the file or the matrix;'</span>);

isEdgeUseSlot            = round(value(var_SingleLink_SingSlot));

yalmip(<span class="string">'clear'</span>);
</pre><p><b>Computation</b></p><pre class="codeinput">NewNetState                    =  Netstate;

A                               = repmat(EXCLUDE_IDDENTICALPAIR, <span class="keyword">...</span>
                                          [1,1,NUM_ROUTE,NUM_CHANNEL] <span class="keyword">...</span>
                                         );
NUM_LIGHTPAHTS                  = sum(delta_sdk_atCh(A));

capacityMatrix                  = sum(sum(<span class="keyword">...</span>
    capacityMatrix_kthRoute_atCh.* delta_sdk_atCh<span class="keyword">...</span>
    , 4)<span class="keyword">...</span>
    , 3);
NewNetState.totalCapacityMatrix = capacityMatrix;

NewNetState.isEdgeUseSlot       = isEdgeUseSlot;

<span class="comment">% ==============================</span>
<span class="comment">% Obtain infos of lightpaths.</span>
<span class="comment">% ==============================</span>

a = find(permute(delta_sdk_atCh,[4,3,2,1])==1);
[vec_Ch_ofp,vec_kidx_ofp,vec_dest_ofp,vec_src_node_ofp] = ind2sub([NUM_CHANNEL, NUM_ROUTE,NUM_NODE,NUM_NODE],a);


LightPathSet         = LightPath(NUM_LIGHTPAHTS, NUM_EDGE);
LightPathSet.nSize   = NUM_LIGHTPAHTS;

<span class="comment">% Assign basic parameters (s,d,k,w)</span>
<span class="keyword">for</span> p = 1 : NUM_LIGHTPAHTS
    LightPathSet.no(p)     = p;

    <span class="comment">% Assign connectionNo</span>
    [cTargetNo] = findNodePairNo(Commodity, [vec_src_node_ofp(p), vec_dest_ofp(p)]);
    assert(~isempty(cTargetNo)<span class="keyword">...</span>
        , <span class="string">'not defined commodity'</span><span class="keyword">...</span>
        );
    LightPathSet.nodePairNo(p)    = cTargetNo;

    LightPathSet.sourceNo(p)        = vec_src_node_ofp(p);
    LightPathSet.destinationNo(p)   = vec_dest_ofp(p);
    LightPathSet.routeNo(p)         = vec_kidx_ofp(p);
    LightPathSet.wavelengthNo(p)    = vec_Ch_ofp(p);
<span class="keyword">end</span>

<span class="comment">% Assign other parameters</span>
<span class="keyword">for</span> p =1:NUM_LIGHTPAHTS
    LightPathSet.isPathUseEdges(p,1:NUM_EDGE) = <span class="keyword">...</span>
        Netstate.isPathOnsdkUseLink(vec_src_node_ofp(p),vec_dest_ofp(p),vec_kidx_ofp(p),1:NUM_EDGE);
<span class="keyword">end</span>
<span class="keyword">for</span> p =1:NUM_LIGHTPAHTS
    LightPathSet.hops(p) = 1 + <span class="keyword">...</span>
        sum(Netstate.isPathOnsdkUseLink(vec_src_node_ofp(p),vec_dest_ofp(p),vec_kidx_ofp(p),1:NUM_EDGE));
<span class="keyword">end</span>
<span class="keyword">for</span> p =1:NUM_LIGHTPAHTS
    LightPathSet.strPath{p}   = printArray(Netstate.candidatePathOfsdk{vec_src_node_ofp(p),vec_dest_ofp(p),vec_kidx_ofp(p)},<span class="string">'-'</span>);
<span class="keyword">end</span>
<span class="keyword">for</span> p =1:NUM_LIGHTPAHTS
    LightPathSet.cost(p)      = Netstate.lengthOfPathOfsdk(vec_src_node_ofp(p),vec_dest_ofp(p),vec_kidx_ofp(p));
<span class="keyword">end</span>
<span class="keyword">for</span> p =1:NUM_LIGHTPAHTS
    LightPathSet.opticalBandNo(p)   = Netstate.opticalBandNoOfSlot(vec_Ch_ofp(p));
<span class="keyword">end</span>
<span class="keyword">for</span> p =1:NUM_LIGHTPAHTS
    LightPathSet.transmissionModeNo(p) = targetMod_kthRoute_atCh(vec_src_node_ofp(p), <span class="keyword">...</span>
        vec_dest_ofp(p), <span class="keyword">...</span>
        vec_kidx_ofp(p), <span class="keyword">...</span>
        vec_Ch_ofp(p));
<span class="keyword">end</span>
<span class="keyword">for</span> p =1:NUM_LIGHTPAHTS
    LightPathSet.transceiverNo(p) = 1;
<span class="keyword">end</span>
<span class="keyword">for</span> p =1:NUM_LIGHTPAHTS
    LightPathSet.capacity(p)        = capacityMatrix_kthRoute_atCh(vec_src_node_ofp(p), <span class="keyword">...</span>
        vec_dest_ofp(p), <span class="keyword">...</span>
        vec_kidx_ofp(p), <span class="keyword">...</span>
        vec_Ch_ofp(p));
<span class="keyword">end</span>
</pre><pre class="codeinput"><span class="keyword">end</span>


<span class="keyword">function</span> new_obj = removeNaN(obj)
    idx          = isnan(obj);
    new_obj      = obj;
    new_obj(idx) = 0;
<span class="keyword">end</span>

<span class="keyword">function</span> [NetworkThroughput, NewNetState,LightPathSet] = <span class="keyword">...</span>
    SequentialLoadingHeu(<span class="keyword">...</span>
    Networks<span class="keyword">...</span>
    , NetState <span class="keyword">...</span>
    , ReferenceCapacity<span class="keyword">...</span>
    , Commodity<span class="keyword">...</span>
    , CandidateOpticalBand <span class="keyword">...</span>
    , CandidateTransponder<span class="keyword">...</span>
    , CandidateModFormat<span class="keyword">...</span>
    , options<span class="keyword">...</span>
    )
</pre><pre>     Sequential loading heuristic</pre><pre>   1: Select Demand
   2: Assess current network usage
   3: if current lightpaths have sufficient capacity then
   4:      Skip current demand and go to 1
   5: else
   6:      Search for a viable lightpath(FF-kSP, kSP-FF)
   7:      if current lightpaths have sufficient capacity then
   8:           Skip current demand and go to 1
   9:      else
   10:           Demand blocked and stop
   11:     end
   12: end</pre><pre>     **LINE 8**
FIXED DEMAND SIZE EQUALS THE MINIMUM POSTIVIE TRANSSSMIION CAPACITY IN
ORDER TO ENSURES ONLY A LIGHTPAHT IS REQUIRED TO ACCOMMODATE DEMAND
OTHERWISE, LINE 8 WOULD BE WRONG</pre><pre>     **LINE 6**
Algorithm indexing strategy (see below)
:: for FF-kSP
(ch,k) : (ch-1) * NUMBER_OF_ROUTES  + k;
   For example,
   +----------------------+---------------------------+--+----------------------+----------------------------+
   |                      |     NUMBER_OF_ROUTES=7    |  |                      |     NUMBER_OF_ROUTES=7     |
   +----------------------+---+---+---+---+---+---+---+--+----------------------+---+---+---+----+---+---+---+
   |                      | 1 | 1 | 1 | 1 | 1 | 1 | 1 |  |                      | 0 | 1 | 2 | 3  | 4 | 5 | 6 |
   |                      +---+---+---+---+---+---+---+--+                      +---+---+---+----+---+---+---+
   |                      | 1 | 1 | 1 | 1 | 0 | 0 | 0 |  |                      | 7 | 8 | 9 | 10 | - | - | - |
   |                      +---+---+---+---+---+---+---+--+                      +---+---+---+----+---+---+---+
   | NUMBER_OF_CHANNELS=5 | 0 | 0 | 0 | 0 | 0 | 0 | 0 |  | NUMBER_OF_CHANNELS=5 | - | - | - | -  | - | - | - |
   |                      +---+---+---+---+---+---+---+--+                      +---+---+---+----+---+---+---+
   |                      | 0 | 0 | 0 | 0 | 0 | 0 | 0 |  |                      | - | - | - | -  | - | - | - |
   |                      +---+---+---+---+---+---+---+--+                      +---+---+---+----+---+---+---+
   |                      | 0 | 0 | 0 | 0 | 0 | 0 | 0 |  |                      | - | - | - | -  | - | - | - |
   +----------------------+---+---+---+---+---+---+---+--+----------------------+---+---+---+----+---+---+---+
:: for kSP-FF
(ch,k) : (k-1) * NUMBER_OF_CHANNELS + ch;
   For example,
   +----------------------+---------------------------+--+----------------------+---------------------------+
   |                      |     NUMBER_OF_ROUTES=7    |  |                      |     NUMBER_OF_ROUTES=7    |
   +----------------------+---+---+---+---+---+---+---+--+----------------------+---+---+---+---+---+---+---+
   |                      | 1 | 1 | 0 | 0 | 0 | 0 | 0 |  |                      | 0 | 5 | - | - | - | - | - |
   |                      +---+---+---+---+---+---+---+--+                      +---+---+---+---+---+---+---+
   |                      | 1 | 1 | 0 | 0 | 0 | 0 | 0 |  |                      | 1 | 6 | - | - | - | - | - |
   |                      +---+---+---+---+---+---+---+--+                      +---+---+---+---+---+---+---+
   | NUMBER_OF_CHANNELS=5 | 1 | 0 | 0 | 0 | 0 | 0 | 0 |  | NUMBER_OF_CHANNELS=5 | 2 | - | - | - | - | - | - |
   |                      +---+---+---+---+---+---+---+--+                      +---+---+---+---+---+---+---+
   |                      | 1 | 0 | 0 | 0 | 0 | 0 | 0 |  |                      | 3 | - | - | - | - | - | - |
   |                      +---+---+---+---+---+---+---+--+                      +---+---+---+---+---+---+---+
   |                      | 1 | 0 | 0 | 0 | 0 | 0 | 0 |  |                      | 4 | - | - | - | - | - | - |
   +----------------------+---+---+---+---+---+---+---+--+----------------------+---+---+---+---+---+---+---+
** Similar paper can refer to [CZLX22, ViIS19, IWLS16]
[CZLX22] Throughput Maximization Leveraging
                 Just-Enough SNR Margin and Channel Spacing Optimization
[ViIS19] Scalable Capacity Estimation for
                 Nonlinear Elastic All-Optical Core Networks
[IWLS16] Using 25 GbE Client Rates to Access
                 the Gains of Adaptive Bit-and Code-Rate Networking</pre><pre>     Selected parameters:
&lt;userSeqDemands&gt;                 : archieved unit demands;
&lt;SeqDemands&gt;                     : psedo-random sequential demands;
&lt;isBlocking_forCommodityNo&gt;      : record blocking for a
                                 connection with CommodityNo (s,d);
   'TerminateStrategy'           : 'fisrt blocking' terminate if any block
                                 : 'AllBlocking' terminate after all filled
&lt;accumBlockingArray_atdemand&gt;    : accumulated blocking after n-th demand</pre><pre>&lt;accumTransceiverArray_atdemand&gt; : accum transceivers after n-th demand
&lt;minimumCapacity&gt;                : fixed-rate demand size
&lt;beta_atlk_sd&gt; and &lt;beta_sdk_atl&gt; are the same except for the dimensions</pre><pre class="language-matlab">Author: chen.cao{at}sjtu.edu.cn; chen_cao_{at}hotmail.com;
</pre><pre class="codeinput"><span class="keyword">if</span>(isa(ReferenceCapacity, <span class="string">'double'</span>))
    capacityMatrix_kthRoute_atOpticalBand_atTRXBaud_withM = ReferenceCapacity;
<span class="keyword">else</span>
    error(<span class="string">'Not defined yet'</span>);
<span class="keyword">end</span>
</pre><h2 id="37">SequentialLoadingHeu: initialize</h2><pre class="codeinput">nLimitedTransceivers = options.costLimit;
NUM_NODE             = Networks.nNodes;
NUM_EDGE             = Networks.nEdges;
NUM_ROUTE            = NetState.nRoutes;
NUM_SLOT             = NetState.nSlots;

beta_sdk_atl         = NetState.isPathOnsdkUseLink;
<span class="comment">% Another form for representing the beta_sdk_atl;</span>
<span class="comment">% (Comment: column indexing is faster than row indexing)</span>
<span class="comment">% Date: 24, Jul. 2023</span>
beta_atlk_sd         = permute(beta_sdk_atl,[4,3,1,2]);

opticalBandNo_ofCh   = NetState.opticalBandNoOfSlot;
nTRxMods             = length(CandidateModFormat);


minimumCapacity     = min(nonzeros(<span class="keyword">...</span>
    capacityMatrix_kthRoute_atOpticalBand_atTRXBaud_withM));
epsilonCapacity     = minimumCapacity*1e-4;
</pre><h2 id="38">SequentialLoadingHeu-step1: generate demands</h2><pre class="codeinput"><span class="comment">% Demand sequences ...</span>
nSamples            = 10000;
<span class="comment">% typically, 16e4 demands required for DT14 with TRx at 50 GBd, &lt;&lt;182e4.</span>

nCommodities        = Commodity.nSize;
rng(options.rngSeed);

pseduoRandomSeqFile = sprintf(<span class="keyword">...</span>
    <span class="string">'data/PseduoRandomDemands-1000/uSeqDemandsC%dN%dR%d.mat'</span><span class="keyword">...</span>
    , nCommodities <span class="keyword">...</span>
    , nSamples<span class="keyword">...</span>
    , options.rngSeed<span class="keyword">...</span>
    );
<span class="keyword">if</span> exist(pseduoRandomSeqFile)
    load(pseduoRandomSeqFile);
<span class="keyword">else</span>
    userSeqDemands          = Demand(nSamples*nCommodities);
    <span class="keyword">for</span> iSample               = 1:nSamples
        <span class="comment">% Random sampling without replacement</span>
        idx = datasample([1:nCommodities],nCommodities,<span class="string">'Replace'</span>,false);
        <span class="comment">% No replacement for high efficiency;</span>

        RandCommodity                   = Commodity.indexing(idx);
        userSeqDemands                  = userSeqDemands.appendn(<span class="keyword">...</span>
                                                    RandCommodity<span class="keyword">...</span>
                                                    , nCommodities<span class="keyword">...</span>
                                                    );
    <span class="keyword">end</span>
    save(pseduoRandomSeqFile, <span class="string">'userSeqDemands'</span>);
<span class="keyword">end</span>
SeqDemands          = copy(userSeqDemands);
<span class="comment">% Note: copy class is safer than assign class, since property mix.copyable.</span>
SeqDemands.flowSize = userSeqDemands.flowSize * minimumCapacity; <span class="comment">%[Gbps]</span>

delete(userSeqDemands);
<span class="comment">% Note: delete a class</span>
</pre><h2 id="39">SequentialLoadingHeu-step2: loading demands sequentially</h2><pre class="codeinput"><span class="comment">% demand status, and lightpath status;</span>
isBlocking_forNodePair          = false(nCommodities,1);
accumBlockingArray_atdemand     = zeros(SeqDemands.nSize,1);
accumTransceiverArray_atdemand  = zeros(SeqDemands.nSize,1);

MAX_LPs_PERNODEPAIR             = round(NUM_SLOT);
LightPathSet                    = LightPath(<span class="keyword">...</span>
                                    MAX_LPs_PERNODEPAIR*nCommodities <span class="keyword">...</span>
                                    , Networks.nEdges<span class="keyword">...</span>
                                  );
fid_log                         = fopen(<span class="string">'Results_heu_log.txt'</span>,<span class="string">'w+'</span>);


<span class="comment">% Determing algorithm type</span>
<span class="comment">% (Comment: num comparison is more efficient than string comparison);</span>
<span class="comment">% Date: 24, Jul. 2023</span>
<span class="keyword">switch</span> (options.algorithmOption.LoadingStrategy)
    <span class="keyword">case</span> <span class="string">'kSP-FF'</span>
        algorithmNo   = 1;
    <span class="keyword">case</span> <span class="string">'FF-kSP'</span>
        algorithmNo   = 2;
    <span class="keyword">otherwise</span>
        error(<span class="string">'not define'</span>);
<span class="keyword">end</span>

OldNetState             = NetState;
<span class="keyword">for</span> iDemand = 1 : SeqDemands.nSize
    nodePairNo          = SeqDemands.nodePairNo(iDemand);
    src                 = SeqDemands.sourceNo(iDemand);
    dst                 = SeqDemands.destinationNo(iDemand);
    demandSizeGbps      = SeqDemands.flowSize(iDemand);

    demandBetweenSD     = NetState.totalDemandMatrix(src,dst);
    capacityBetweenSD   = NetState.totalCapacityMatrix(src,dst);

    <span class="comment">%      Capacity of three options (upgrading mods., increasing transceivers, reconfiguration.)</span>
    capacityByMod       = 0; <span class="comment">% Option 1</span>

    fprintf(fid_log,<span class="string">"&lt;&lt;Current requirement traffic of logical connection (%d,%d): %g\n"</span>,src,dst,demandBetweenSD + demandSizeGbps);
    fprintf(fid_log,<span class="string">" On node pair (%d,%d), the provsioned traffic: %g. \n"</span>,src,dst,capacityBetweenSD);

    <span class="comment">% ==============================</span>
    <span class="comment">%	Sequential network status.</span>
    <span class="comment">% ==============================</span>
    <span class="comment">%       - network blocking;</span>
    accumBlockingArray_atdemand(iDemand) = accumBlockingArray_atdemand(max(iDemand-1,1));
    <span class="keyword">if</span>((isBlocking_forNodePair(nodePairNo)==true)) <span class="comment">% Record accumBlocking status if (src,dst) is already blocked.</span>
        accumBlockingArray_atdemand(iDemand) = accumBlockingArray_atdemand(max(iDemand-1,1)) + 1;
    <span class="keyword">end</span>

    <span class="comment">%       - no. transceivers.</span>
    accumTransceiverArray_atdemand(iDemand) = accumTransceiverArray_atdemand(max(iDemand-1,1));

    isAccommodated      = false; <span class="comment">% true if the current demand is accepted;</span>
    isEstablished       = false; <span class="comment">% true if a new lightpath is established;</span>

    <span class="keyword">if</span>((isBlocking_forNodePair(nodePairNo)==true) || <span class="keyword">...</span>
            (capacityBetweenSD&gt;=demandBetweenSD+demandSizeGbps) || <span class="keyword">...</span>
            (epsilonCapacity&gt;=abs(demandBetweenSD+demandSizeGbps - capacityBetweenSD) ) )
        <span class="comment">% no requirement for the updating;</span>
        <span class="comment">% Comment: epsilonCapacity is used to fix bug when &gt;= loses accuray.</span>
        fprintf(fid_log,<span class="string">"[keep] \n"</span>);
        isAccommodated  = true;
        NetState.totalDemandMatrix(src,dst) = NetState.totalDemandMatrix(src,dst) + demandSizeGbps;
        <span class="keyword">continue</span>;
    <span class="keyword">else</span>
        fprintf(fid_log,<span class="string">"[Needs network operation]: update mods., create a lightpath, or reconfigure between node pair\n"</span>);
        isAccommodated   = false;
    <span class="keyword">end</span>

    <span class="keyword">if</span>(~isAccommodated &amp;&amp; <span class="keyword">...</span>
            LightPathSet.nSize&lt;nLimitedTransceivers)
        <span class="comment">% Skip if the transceiver count exceeds the maximum number.</span>
        <span class="comment">%==============================</span>
        <span class="comment">%     Method 3 :  Establish new lightpath;</span>
        <span class="comment">% :: Only one lightpath would be enough, as the demand is the minimum positive</span>
        <span class="comment">% ==============================</span>
        fprintf(fid_log,<span class="string">"Method : establish a new lightpath\n"</span>);

        iLastSearching = NetState.userParameters(src,dst);
        <span class="keyword">for</span> iSearching = (iLastSearching+1): NUM_SLOT* NUM_ROUTE
            <span class="keyword">switch</span> (algorithmNo)
                <span class="keyword">case</span> 1 <span class="comment">% 'kSP-FF'</span>
                    [iChannel,iRoute]   = revertRouteChannel(iSearching,NUM_SLOT, NUM_ROUTE);
                <span class="keyword">case</span> 2 <span class="comment">% 'FF-kSP'</span>
                    [iChannel,iRoute]   = revertChannelRoute(iSearching,NUM_SLOT, NUM_ROUTE);
                <span class="keyword">otherwise</span>
                    error(<span class="string">'not define'</span>);
            <span class="keyword">end</span>

            bin_edge = logical(beta_atlk_sd(1:NUM_EDGE,iRoute,src,dst));
            bin_inspectionSlots = NetState.isEdgeUseSlot(bin_edge,iChannel);
            <span class="keyword">if</span>(any(any(bin_inspectionSlots)))
                <span class="keyword">continue</span>; <span class="comment">% Skip searching if all slots are occupied</span>
            <span class="keyword">end</span>

            tb  = 1;
            [capacityByNewLightPath, targetm] = max( <span class="keyword">...</span>
                capacityMatrix_kthRoute_atOpticalBand_atTRXBaud_withM(<span class="keyword">...</span>
                src,dst,iRoute,opticalBandNo_ofCh(iChannel),tb,1:nTRxMods)<span class="keyword">...</span>
                );
            <span class="keyword">if</span>(capacityByNewLightPath&gt;=epsilonCapacity&amp;&amp;capacityBetweenSD <span class="keyword">...</span>
                    + capacityByMod + capacityByNewLightPath &gt;= <span class="keyword">...</span>
                    demandSizeGbps+demandBetweenSD)
                fprintf(fid_log,<span class="string">"Accepted current lighpath p&lt;%d,%d,%d,%d,%d&gt; (%g + %g + %g &gt;= %g)\n"</span>,<span class="keyword">...</span>
                    src,dst, iRoute, iChannel, targetm, <span class="keyword">...</span>
                    capacityBetweenSD, capacityByMod,capacityByNewLightPath,<span class="keyword">...</span>
                    demandSizeGbps+demandBetweenSD<span class="keyword">...</span>
                    );
                isEstablished = true;
                <span class="keyword">break</span>;
            <span class="keyword">end</span>
        <span class="keyword">end</span>
        <span class="comment">% % ------------------------------</span>
        <span class="comment">% Update last searching index only if current index is non-empty.</span>
        <span class="comment">% (Comment: empty index occurs when its value exceeds</span>
        <span class="comment">%           NUMBER_OF_CHANNELS* NUMBER_OF_ROUTES)</span>
        <span class="keyword">if</span> isempty(iSearching) == false
            NetState.userParameters(src, dst) = iSearching;
        <span class="keyword">end</span>
        <span class="keyword">if</span> isEstablished
            fprintf(fid_log,<span class="string">"&gt;&gt;&gt;&gt;Summary of method 3: Okay, lightpath found succcessed\n"</span>);
            pid	= LightPathSet.nSize + 1;

            LightPathSet.nSize = LightPathSet.nSize  +1;
            LightPathSet.nodePairNo(pid) = nodePairNo;
            LightPathSet.no(pid) = pid;
            LightPathSet.sourceNo(pid) = src;
            LightPathSet.destinationNo(pid) = dst;
            LightPathSet.routeNo(pid) = iRoute;
            LightPathSet.isPathUseEdges(pid,1:NUM_EDGE) = bin_edge(1:NUM_EDGE);
            LightPathSet.transmissionModeNo(pid) = targetm;
            LightPathSet.transceiverNo(pid) = tb;
            LightPathSet.nFrequencySlots(pid) = 1;
            LightPathSet.wavelengthNo(pid) = iChannel;
            LightPathSet.opticalBandNo(pid) = opticalBandNo_ofCh(iChannel);
            LightPathSet.capacity(pid) = <span class="keyword">...</span>
                capacityMatrix_kthRoute_atOpticalBand_atTRXBaud_withM(<span class="keyword">...</span>
                src,dst,iRoute,opticalBandNo_ofCh(iChannel),tb, targetm);

            LightPathSet.strPath{pid} = printArray(NetState.candidatePathOfsdk{src, dst, iRoute});
            isAccommodated =true;
        <span class="keyword">else</span>
            isAccommodated;
        <span class="keyword">end</span>



    <span class="keyword">end</span>

    fprintf(fid_log,<span class="keyword">...</span>
        <span class="string">"\n&gt;&gt;&gt;&gt;Summary: update the current (%d,%d) node pair, current:required = %g:%g\n"</span>,<span class="keyword">...</span>
        src,dst,<span class="keyword">...</span>
        capacityBetweenSD + capacityByMod +  capacityByNewLightPath,<span class="keyword">...</span>
        demandBetweenSD + demandSizeGbps);
    <span class="keyword">if</span>(~isAccommodated&amp;&amp;~isEstablished)
        fprintf(fid_log,<span class="string">"It's failed, and we donot update the lightpath.\n"</span>);
        isBlocking_forNodePair(nodePairNo) = true;
        accumBlockingArray_atdemand(iDemand) = <span class="keyword">...</span>
            accumBlockingArray_atdemand(iDemand-1) + 1;
    <span class="keyword">end</span>

    <span class="comment">% ==============================</span>
    <span class="comment">%         Update for next traffic demand.</span>
    <span class="comment">% ==============================</span>
    <span class="keyword">if</span> isEstablished
        NetState.isEdgeUseSlot(LightPathSet.isPathUseEdges(pid,1:NUM_EDGE),<span class="keyword">...</span>
            LightPathSet.wavelengthNo(pid)) = true;
        NetState.totalCapacityMatrix(src,dst) = <span class="keyword">...</span>
            NetState.totalCapacityMatrix(src,dst) <span class="keyword">...</span>
            + LightPathSet.capacity(pid);
        NetState.totalDemandMatrix(src,dst) = <span class="keyword">...</span>
            NetState.totalDemandMatrix(src,dst) + demandSizeGbps;
        OldNetState = NetState;
        accumTransceiverArray_atdemand(iDemand) = <span class="keyword">...</span>
            accumTransceiverArray_atdemand(iDemand) + 1;
    <span class="keyword">else</span>
        NetState = OldNetState;
    <span class="keyword">end</span>

    <span class="comment">% ==============================</span>
    <span class="comment">%         Update for next node pair.</span>
    <span class="comment">% ==============================</span>
    <span class="keyword">switch</span>(options.algorithmOption.TerminateStrategy)
        <span class="keyword">case</span> <span class="string">'First-blocking'</span><span class="comment">% Case 1: Terminate if &lt;any is blocked&gt; .</span>
            isTerminate = any(isBlocking_forNodePair == 1);
        <span class="keyword">case</span> <span class="string">'All-blocking'</span><span class="comment">% Case 2: Terminate if &lt;all are blocked&gt; .</span>
            isTerminate = all(isBlocking_forNodePair == 1);
        <span class="keyword">otherwise</span>
            error(<span class="string">'not specified'</span>);
    <span class="keyword">end</span>

    <span class="comment">% ==============================</span>
    <span class="comment">% Plot Network.</span>
    <span class="comment">% ==============================</span>
    <span class="comment">%     pause(0.1);</span>
    <span class="comment">%     if(isEstablished)</span>
    <span class="comment">%     pause(0.001);</span>
    <span class="comment">%     figure(87),</span>
    <span class="comment">%     clf;</span>
    <span class="comment">%     imagesc(logical(NetState.isEdgeUseSlot));colorbar;</span>
    <span class="comment">%     title('Spectrum Usage Graph');</span>
    <span class="comment">%     xlabel('Slot');</span>
    <span class="comment">%     ylabel('Link');</span>
    <span class="comment">%     end</span>
    <span class="comment">% ==============================</span>
    <span class="comment">%     Print out results.</span>
    <span class="comment">% ==============================</span>
    fprintf(fid_log,<span class="string">"\n\nThe current informations of network\n"</span>);
<span class="comment">%     for iNodePair = 1:Networks.nNodes*(Networks.nNodes-1)</span>
<span class="comment">%         fprintf(fid_log,"The number of lighpaths is %d (NodePairID = %d), capacity = %g\n", LightPathSet_OfNodePair(iNodePair).nSize,...</span>
<span class="comment">%             iNodePair,...</span>
<span class="comment">%             NetState.totalCapacityMatrix(Commodity.source(iNodePair), Commodity.destination(iNodePair)));</span>
<span class="comment">%     end</span>
    <span class="keyword">if</span>(isTerminate)
        fprintf(fid_log,<span class="string">"We force to terminate the program\n"</span>);
        <span class="keyword">break</span>;
    <span class="keyword">end</span>
    fprintf(fid_log,<span class="keyword">...</span>
        <span class="string">"The current round number is %d with network throughput: %g \n"</span>,<span class="keyword">...</span>
        iDemand, min(min(NetState.totalDemandMatrix./NetState.normDemandMatrix)));
<span class="keyword">end</span>
fclose(fid_log); <span class="comment">% close file after the loading is stopped.</span>

<span class="keyword">if</span> iDemand == SeqDemands.nSize
    fprintf(<span class="string">'Terminate after full samplings\n'</span>);
<span class="keyword">elseif</span> isTerminate == 1
    fprintf(<span class="string">'Terminate after blocking\n'</span>);
<span class="keyword">else</span>
    ;
<span class="keyword">end</span>
</pre><pre class="codeoutput">Terminate after blocking
</pre><h2 id="40">SequentialLoadingHeu-step3: return demands and capacity</h2><pre class="codeinput">NewNetState          = OldNetState;
STATUS_ACTIVE_CONNECTIONS= NetState.STATUS_ACTIVE_CONNECTIONS;
NetworkThroughput    = min(NetState.totalCapacityMatrix(STATUS_ACTIVE_CONNECTIONS)<span class="keyword">...</span>
    ./ NetState.normDemandMatrix(STATUS_ACTIVE_CONNECTIONS));
<span class="comment">% Mark: There could be different meanings on the throughput.</span>
<span class="comment">%   We denote network throughput by the working demand</span>
</pre><pre class="codeinput"><span class="keyword">end</span>


<span class="keyword">function</span> [newBand] = assignSlotPosition(oldBand)
<span class="comment">%       update candidate optical band's beginning and ending slots.</span>

[nBands]                = length(oldBand);
vec_nSlot_atOpticalBand = getNumeric(oldBand<span class="keyword">...</span>
    , <span class="string">'nFrequencySlots'</span>);

vec_slotBegin_atBand   = cumsum([1;vec_nSlot_atOpticalBand(:)]);
vec_slotEnd_atBand     = cumsum([0;vec_nSlot_atOpticalBand(:)]);
assert(all(rem(vec_slotBegin_atBand,1) == 0) <span class="keyword">...</span>
    , <span class="string">'MATLAB:assignSlotPosition:UnExpectedResults'</span> <span class="keyword">...</span>
    , <span class="string">'Wrong Slots Setting'</span><span class="keyword">...</span>
    ); <span class="comment">% Check non-integer slots beginning</span>

<span class="comment">% Update optical band's start and end slots status</span>
newBand = oldBand;
<span class="keyword">for</span> iBand = 1:nBands
   newBand(iBand).sbegin = vec_slotBegin_atBand(iBand);
   newBand(iBand).send   = vec_slotEnd_atBand(iBand+1);
<span class="keyword">end</span>

<span class="keyword">end</span>

<span class="keyword">function</span> [isEdgeUseSlot, opticalBandNoOnSlot] = initializeEdgeSlot(<span class="keyword">...</span>
    isEdgeUseBand <span class="keyword">...</span>
    , candidateBand<span class="keyword">...</span>
    )
<span class="comment">% compute initial slot and optical band information for each edge.</span>

[nEdges, nBands] = size(isEdgeUseBand);
vec_nSlot_atBand = getNumeric(candidateBand, <span class="string">'nFrequencySlots'</span>);
nSlots           = sum(vec_nSlot_atBand);

isEdgeUseSlot    = ones(nEdges, nSlots);
<span class="keyword">for</span> iEdges = 1 : nEdges
    <span class="keyword">for</span> jBand = 1 : nBands
        thisBand = candidateBand(jBand);
        <span class="keyword">if</span>(isEdgeUseBand(iEdges, jBand) == 1 <span class="keyword">...</span>
                &amp;&amp; all(all(<span class="keyword">...</span>
                isEdgeUseSlot(iEdges,thisBand.sbegin : thisBand.send) == 1 <span class="keyword">...</span>
                )<span class="keyword">...</span>
                )<span class="keyword">...</span>
                )
            isEdgeUseSlot(iEdges,thisBand.sbegin : thisBand.send) = 0;
        <span class="keyword">end</span>
    <span class="keyword">end</span>
<span class="keyword">end</span>

<span class="comment">% Optical band ID;</span>
<span class="comment">% id = -1 : for NULL,</span>
<span class="comment">% id =  0 : for channel crossed-by two bands;</span>
<span class="comment">% id &gt;= 1 : channel ID</span>
opticalBandNoOnSlot = -1 + zeros(nSlots,1);
<span class="keyword">for</span> iiBand = 1 : nBands
    thisBand = candidateBand(iiBand);
    opticalBandNoOnSlot(thisBand.sbegin : thisBand.send) = iiBand;
<span class="keyword">end</span>

<span class="keyword">end</span>

<span class="keyword">function</span> [newObj] = sortClass(oldObj, keyName, direction)
<span class="comment">% return class array according to the class's keyname type.</span>

nObj = length(oldObj);
assert(any(strcmp(properties(oldObj(1)), keyName)) <span class="keyword">...</span>
    , <span class="string">'MATLAB:sortClass:UnMatchName'</span> <span class="keyword">...</span>
    , <span class="string">'no such properties!'</span><span class="keyword">...</span>
    );

<span class="comment">% Check size of input argument</span>
<span class="keyword">try</span>
    narginchk(2,3);
<span class="keyword">catch</span> ME
    error(ME.message);
<span class="keyword">end</span>

<span class="keyword">if</span> nargin == 2
    direction = <span class="string">'ascend'</span>;
<span class="keyword">else</span>
    <span class="comment">% deal with other 3 inputs</span>
<span class="keyword">end</span>

metrics           = zeros(1,nObj);
<span class="keyword">for</span> iObj = 1 : nObj
    thisObj       = oldObj(iObj);
    metrics(iObj) = thisObj.(keyName);
<span class="keyword">end</span> <span class="comment">%</span>

[~, idx_sort] = sort(metrics,direction);
newObj        = oldObj;

<span class="keyword">for</span> iiObj = 1 : nObj
    newObj(iiObj) = oldObj(idx_sort(iiObj));
<span class="keyword">end</span> <span class="comment">%</span>

<span class="keyword">end</span>


<span class="keyword">function</span> [TotalTransmissionMode, nTotalTransmissionModes] = <span class="keyword">...</span>
    initializeTransmissionMode(SimulationSetting)

defaultBaud = SimulationSetting.(<span class="string">'default_baud_rate'</span>);
<span class="comment">% defaultBaud = 50; % #demo: example capacity for 50 Gbps per step.</span>

namePattern             = <span class="string">'^PM_'</span>;
nameList                = findFieldNames(SimulationSetting, namePattern);
nTotalTransmissionModes = length(nameList);

TotalTransmissionMode     = [];
<span class="keyword">for</span> iMod = 1 : nTotalTransmissionModes
    keyName        = nameList{iMod};

    valueArray     = SimulationSetting.(keyName);
    ValueStructure = struct(<span class="keyword">...</span>
        <span class="string">'name'</span>,         keyName<span class="keyword">...</span>
        ,<span class="string">'SNRdB'</span>,       valueArray(1) <span class="keyword">...</span>
        ,<span class="string">'dataRate'</span>,    valueArray(2) <span class="keyword">...</span>
        ,<span class="string">'reach'</span>,       valueArray(3) <span class="keyword">...</span>
        ,<span class="string">'defaultBaud'</span>, defaultBaud   <span class="keyword">...</span>
        );;
    thisMode        = TransmissionMode(ValueStructure);

    TotalTransmissionMode = [TotalTransmissionMode, thisMode];
<span class="keyword">end</span>

<span class="keyword">end</span>

<span class="keyword">function</span>  [TotalTransceiver,nTotalTransceiver] = <span class="keyword">...</span>
    initializeTransceiver(SimulationSetting)
    <span class="comment">% find possible names with filed pattern '^Trans\w*[G]'</span>
    <span class="comment">% initialize transceivers with the value of this fields.</span>

    <span class="comment">% find names;</span>
    namePattern         = <span class="string">'^Trans\w*[G]'</span>;
    nameList            = findFieldNames(SimulationSetting,namePattern);
    nTotalTransceiver   = length(nameList);

    <span class="comment">% initialize transceivers</span>
    TotalTransceiver = [];
    <span class="keyword">for</span> iTransceiver = 1 : nTotalTransceiver
        thisName        = nameList{iTransceiver};
        valueArray      = SimulationSetting.(thisName);
        ValueStructure  = struct(<span class="string">'name'</span>,    thisName<span class="keyword">...</span>
            ,<span class="string">'bandwidth'</span>,                   valueArray(1)<span class="keyword">...</span>
            ,<span class="string">'numberOfFrequencySlots'</span>,      valueArray(2) <span class="keyword">...</span>
            ,<span class="string">'capacity'</span>,                    valueArray(3) <span class="keyword">...</span>
            ,<span class="string">'penalty'</span>,                     valueArray(4) <span class="keyword">...</span>
            ,<span class="string">'baud_rate'</span>,                   valueArray(5) <span class="keyword">...</span>
            );
        Trans_xG         = Transceiver(ValueStructure);
        TotalTransceiver = [TotalTransceiver, Trans_xG];
    <span class="keyword">end</span>
<span class="keyword">end</span>

<span class="keyword">function</span> [isEdgeUseOpticalBand] = <span class="keyword">...</span>
    initializeFiberOpticalBand(Networks <span class="keyword">...</span>
    , candidateOpticalBandArray <span class="keyword">...</span>
    , bandProfileSetting)

isEdgeUseOpticalBand = <span class="keyword">...</span>
    zeros(Networks.nEdges, numel(candidateOpticalBandArray));
<span class="keyword">for</span> iEdge = 1 : Networks.nEdges

    <span class="comment">%     find optical band settings, on a link &lt;iEdge&gt;</span>
    [mNode,nNode]   = find(Networks.edgeIndexMatrix==iEdge);
    searchPattern   = sprintf(<span class="string">'link_%dto%d$'</span>,mNode,nNode);
    nameList        = findFieldNames(bandProfileSetting, searchPattern);
    assert(<span class="keyword">...</span>
        length(nameList) == 1 <span class="keyword">...</span>
        ,<span class="string">'MATLAB:intializeFiberOpticalBand:UnMatchedSize'</span><span class="keyword">...</span>
        ,<span class="string">'not proper wide-band settings'</span><span class="keyword">...</span>
        );

    bandNames       = bandProfileSetting.(nameList{1});
    [OpticalBandArray,nOpticalBand] = getClassByFields(<span class="keyword">...</span>
        bandNames, <span class="string">'name'</span>, candidateOpticalBandArray);

    <span class="keyword">for</span> jOpticalBand = 1 : nOpticalBand
        <span class="keyword">for</span> kOpticalBand = 1 : length(candidateOpticalBandArray)
            <span class="comment">%  true (1) if name matches candidateOpticalBand,</span>
            <span class="comment">%  false(0) otherwise.</span>
            <span class="comment">%  Note: We designate the optical band No of the candidate</span>
            <span class="comment">%         optical band.</span>
            <span class="keyword">if</span>(strcmp(<span class="keyword">...</span>
                    OpticalBandArray(jOpticalBand).name <span class="keyword">...</span>
                    , candidateOpticalBandArray(kOpticalBand).name<span class="keyword">...</span>
                    ))
                isEdgeUseOpticalBand(iEdge, kOpticalBand) = true;
                <span class="keyword">break</span>;
            <span class="keyword">else</span>
                isEdgeUseOpticalBand(iEdge, kOpticalBand) = false;
            <span class="keyword">end</span>
        <span class="keyword">end</span>
    <span class="keyword">end</span>
<span class="keyword">end</span>

<span class="keyword">end</span>


<span class="keyword">function</span> MultiCommodityFlow = initializeCommodityFlows(SimulationSetting)

nCommodiyFlow      = length(SimulationSetting.commodity_src);
MultiCommodityFlow = Demand(nCommodiyFlow);

MultiCommodityFlow.nSize(1) = nCommodiyFlow;

MultiCommodityFlow.no(1 : nCommodiyFlow) = <span class="keyword">...</span>
    [1 : length(SimulationSetting.commodity_src)];

MultiCommodityFlow.nodePairNo(1:nCommodiyFlow) = <span class="keyword">...</span>
    [1 : length(SimulationSetting.commodity_src)];

MultiCommodityFlow.sourceNo(1:nCommodiyFlow) = <span class="keyword">...</span>
    SimulationSetting.commodity_src;

MultiCommodityFlow.destinationNo(1:nCommodiyFlow) = <span class="keyword">...</span>
    SimulationSetting.commodity_dst;

MultiCommodityFlow.flowSize(1:nCommodiyFlow) = <span class="keyword">...</span>
    SimulationSetting.commodity_amount;

assert( <span class="keyword">...</span>
       numel(MultiCommodityFlow.sourceNo)     == MultiCommodityFlow.nSize <span class="keyword">...</span>
    &amp;&amp; numel(MultiCommodityFlow.destinationNo)== MultiCommodityFlow.nSize <span class="keyword">...</span>
    &amp;&amp; numel(MultiCommodityFlow.flowSize)     == MultiCommodityFlow.nSize<span class="keyword">...</span>
    , <span class="string">'MATLAB:intializeCommodityFlows:UnMatchedSize'</span><span class="keyword">...</span>
    , <span class="string">'Wrong commodity flow'</span><span class="keyword">...</span>
    );
assert(length(unique(<span class="keyword">...</span>
    [MultiCommodityFlow.sourceNo, MultiCommodityFlow.destinationNo], <span class="string">'rows'</span><span class="keyword">...</span>
    )) == MultiCommodityFlow.nSize <span class="keyword">...</span>
    ,<span class="string">'MATLAB:intializeCommodityFlows:UnExpectedSize'</span><span class="keyword">...</span>
    ,<span class="string">'Replicated Commodity'</span><span class="keyword">...</span>
    );
<span class="keyword">end</span>

<span class="keyword">function</span> [TotalOpticalBand, nTotalOpticalBand, frequencySlots] = <span class="keyword">...</span>
    initializeOpticalBand(SimulationSetting)
frequencySlots      = SimulationSetting.frequency_slots;

<span class="comment">% Import UWB name;</span>
searchPattern       =<span class="string">'[a-zA-Z]Band$'</span>;
nameOfOpticalBands  = findFieldNames(SimulationSetting,searchPattern);
nTotalOpticalBand   = length(nameOfOpticalBands);

TotalOpticalBand            = [];
<span class="keyword">for</span> i = 1:nTotalOpticalBand
    keyName         = nameOfOpticalBands{i};
    valueArray      = SimulationSetting.(keyName);
    ValueStructure  = struct(<span class="string">'name'</span>,keyName <span class="keyword">...</span>
        ,<span class="string">'spectrum_resource'</span>,       valueArray(1)<span class="keyword">...</span>
        ,<span class="string">'max_transceivers'</span>,        valueArray(2) <span class="keyword">...</span>
        ,<span class="string">'SNRpenaltydB'</span>,            valueArray(3) <span class="keyword">...</span>
        ,<span class="string">'center_frequency'</span>,        valueArray(4) <span class="keyword">...</span>
        ,<span class="string">'frequency_slots'</span>,         frequencySlots<span class="keyword">...</span>
        );

    TotalOpticalBand = [TotalOpticalBand, <span class="keyword">...</span>
        OpticalBand(ValueStructure)];
<span class="keyword">end</span>

<span class="keyword">end</span>

<span class="keyword">function</span> userNetworks = <span class="keyword">...</span>
    initializeNetworks(networkTag, distanceMatrix, longitudeArray, latitudeArray)
</pre><pre class="codeinput"><span class="comment">% user-defined network initialization.</span>
<span class="comment">%   default_networks[struct]:</span>
<span class="comment">%       'NoNodes'            : [1] number of nodes, size of node set V;</span>
<span class="comment">%       'NoEdges'            : [1] number of edges, size of edge set E;</span>
<span class="comment">%       'adjacentMatrix'     : [matrix |V|*|V|] adjacency matrix of a network,  (u,v) : 1 if u is connected with v, 0 otherwise.</span>
<span class="comment">%       'edgeIndexMatrix'    : [matrix |V|*|V|] adjacency matrix with ID index, (u,v) : LinkID for the l-th links in a network.</span>
<span class="comment">%                         e.g., for a 4-node ring;</span>
<span class="comment">%                               AdjacentMatrix is</span>
<span class="comment">%                                 [0 1 0 1;</span>
<span class="comment">%                                 1 0 1 0;</span>
<span class="comment">%                                 0 1 0 1;</span>
<span class="comment">%                                 1 0 1 0];</span>
<span class="comment">%                               LinkIndexMatrix is</span>
<span class="comment">%                                 [0 3 0 7;</span>
<span class="comment">%                                 1 0 5 0;</span>
<span class="comment">%                                 0 4 0 8;</span>
<span class="comment">%                                 2 0 6 0];</span>
<span class="comment">%       'distanceMatrix'     : [matrix |V|*|V|] Physical-distance for an edge (u, v), 0 if (u,v) are not connected.</span>
<span class="comment">%       'vec_length_atl'     : length of a link;</span>
<span class="comment">%       'longtitudeArray'    : [matrix |V|*1]   east-west position of a point in the earth</span>
<span class="comment">%       'latitudeArray'      : [matrix |V|*1]   south-north position of a point in the earth</span>
<span class="comment">%       'Diameter'           : [1] longest shortest path;</span>
<span class="comment">% 'distanceShortestPathMatrix': [matrix |V|*|V|] length of the shortest path between (s,d);</span>
<span class="comment">% ==============================</span>
<span class="comment">%           Topology</span>
<span class="comment">% ==============================</span>
default_networks = struct(<span class="keyword">...</span>
    <span class="string">'tag'</span>, [],<span class="keyword">...</span>
    <span class="string">'nNodes'</span>, [], <span class="keyword">...</span>
    <span class="string">'nEdges'</span>, [], <span class="keyword">...</span>
    <span class="string">'adjacentMatrix'</span>, [], <span class="keyword">...</span>
    <span class="string">'edgeIndexMatrix'</span>, [], <span class="keyword">...</span>
    <span class="string">'distanceMatrix'</span>, [], <span class="keyword">...</span>
    <span class="string">'linkLengthArray'</span>, [], <span class="keyword">...</span>
    <span class="string">'longtitudeArray'</span>, [], <span class="keyword">...</span>
    <span class="string">'latitudeArray'</span>, [], <span class="keyword">...</span>
    <span class="string">'diameter'</span>, [], <span class="keyword">...</span>
    <span class="string">'distanceShortestPathMat'</span>, []<span class="keyword">...</span>
    );
</pre><pre class="codeinput">userNetworks     = default_networks;
userNetworks.tag = networkTag;

NUM_NODE         = size(distanceMatrix,1);
NUM_EDGE         = sum(sum(logical(distanceMatrix)));
adjacentMatrix   = logical(distanceMatrix);

<span class="comment">% Check for no. nodes</span>
<span class="comment">% assert((nNodes==numel(longitudeArray) || nNodes*~isempty(longitudeArray)==numel(longitudeArray) ) ...</span>
<span class="comment">%     &amp;&amp; (nNodes==numel(latitudeArray) || nNodes*~isempty(latitudeArray)==numel(latitudeArray) ) ...</span>
<span class="comment">%     , 'Wrong location coordinate');</span>
assert(<span class="keyword">...</span>
      (NUM_NODE == numel(longitudeArray))<span class="keyword">...</span>
    &amp;&amp;(NUM_NODE == numel(latitudeArray)) <span class="keyword">...</span>
    , <span class="string">'MATLAB:initializeNetworks:UnMatchedSize'</span><span class="keyword">...</span>
    , <span class="string">'Wrong location coordinate'</span><span class="keyword">...</span>
    );

<span class="comment">% Check bi-connected graph : avoid sole island</span>
assert(<span class="keyword">...</span>
    all(computeNodeDegree(adjacentMatrix) ~= 0)<span class="keyword">...</span>
    , <span class="string">'MATLAB:initializeNetworks:InvalidInput'</span><span class="keyword">...</span>
    , <span class="string">'Unsatisifed Matrix, sole node island'</span><span class="keyword">...</span>
    );

<span class="comment">% ==============================</span>
<span class="comment">% Basic parameters initializing</span>
<span class="comment">% ==============================</span>
userNetworks.adjacentMatrix = logical(distanceMatrix);
userNetworks.distanceMatrix = distanceMatrix;
userNetworks.linkLengthArray= distanceMatrix(logical(distanceMatrix));
<span class="comment">% Note: EdgeWeightSet, first-row indexing as matlab default</span>
userNetworks.nNodes         = NUM_NODE;
userNetworks.nEdges         = NUM_EDGE;
userNetworks.latitudeArray  = latitudeArray;
userNetworks.longtitudeArray= longitudeArray;

<span class="comment">% ==============================</span>
<span class="comment">% Advanced initialzation initializing (one block for one parameter)</span>
<span class="comment">% ==============================</span>
edgeIndexMatrix           	= zeros(NUM_NODE,NUM_NODE);
indexOfEdge = 0;
<span class="keyword">for</span> d = 1:NUM_NODE
    <span class="keyword">for</span> s = 1:NUM_NODE
        <span class="keyword">if</span>(adjacentMatrix(s,d)==true)
            indexOfEdge         = indexOfEdge +1;
            edgeIndexMatrix(s,d) = indexOfEdge;
        <span class="keyword">else</span>
            edgeIndexMatrix(s,d) = 0;
        <span class="keyword">end</span>
    <span class="keyword">end</span>
<span class="keyword">end</span>
userNetworks.edgeIndexMatrix = edgeIndexMatrix;

costMatrix = fixCostMatrix(distanceMatrix); <span class="comment">% MATLAB version.</span>

distanceShortestPathMatrix = zeros(NUM_NODE,NUM_NODE);
<span class="keyword">for</span> s = 1 : NUM_NODE
    <span class="keyword">for</span> d = 1 : NUM_NODE
        <span class="keyword">if</span> s == d
            <span class="keyword">continue</span>;
        <span class="keyword">end</span>
        [~,pathLength] = kShortestPath(costMatrix,s,d,1);
        <span class="keyword">if</span>(isempty(pathLength))
            distanceShortestPathMatrix(s,d) = NaN;
            <span class="keyword">continue</span>;
        <span class="keyword">end</span>
        distanceShortestPathMatrix(s,d) = pathLength;
    <span class="keyword">end</span>
<span class="keyword">end</span>
userNetworks.diameter     = max(max(distanceShortestPathMatrix));

userNetworks.distanceShortestPathMat = distanceShortestPathMatrix;

fprintf(<span class="string">'Max Shortestpath= %g * 100km\n'</span>, max(max(distanceShortestPathMatrix)));
</pre><pre class="codeoutput">Max Shortestpath= 11 * 100km
</pre><pre class="codeinput"><span class="keyword">end</span>

<span class="keyword">function</span> UserNetstate = <span class="keyword">...</span>
    initializeNetworkState(Networks, nRoutes, nSlots, Commodity)
<span class="comment">% user-defined network state function.</span>
<span class="comment">%   netstate:</span>
<span class="comment">%       'nSlots'         : [1] number_of_slots, number of wavelengths, W, etc.;</span>
<span class="comment">%       'nRoutes'        : [1] number of candidate routes, K;</span>
<span class="comment">%  'candidatePathOfsdk'  : [cell matrix |V|*|V|*K] all candidate paths;</span>
<span class="comment">%  'lengthOfPathOfsdk'   : [matrix |V|*|V|*K] length of these candidate paths;</span>
<span class="comment">%</span>
<span class="comment">%  'isPathOnsdkUseLink'  : [matrix |V|*|V|*K*|E|] boolean whether p(s,d,k)</span>
<span class="comment">%                          uses the lth link. In case path_(s,d,k) does not</span>
<span class="comment">%                          exist, we assume p(s,d,k) occupying all edges</span>
<span class="comment">%                          with full resource utilization.</span>
<span class="comment">%   'normDemandMatrix'   : [matrix |V|*|V|] normalized traffic demand</span>
<span class="comment">%                          profile in a network, 0\leq D(s,d)\leq 1.</span>
<span class="comment">%       'LinkSlotBlock'  : [matrix |E|*W] logical matrix indicating</span>
<span class="comment">%                           occupied status of l-th edge and w-th wavelength</span>
<span class="comment">%   'totalCapacityMatrix': [matrix |V|*|V|] Ts,d, transmission capacity matrix</span>
<span class="comment">%   'totalDemandMatrix'  : [matrix |V|*|V|] Ts,d, demand capacity matrix</span>
<span class="comment">%                          between (s,d) ;</span>
<span class="comment">%</span>
<span class="comment">%  'userParameters'          : no exact meanings, customed by users.</span>
<span class="comment">%'STATUS_ACTIVE_CONNECTIONS' : [matrix |V|*|V|] acitve connections by</span>
<span class="comment">%                              &lt;normalizedDemand&gt;</span>
<span class="comment">%'STATUS_TRUE_CONNECTIONS'   : [matrix |V|*|V|] true connections,</span>
<span class="comment">%                              Mat(s,d) eq 1, for all s\neq d;</span>
default_netstate = struct(<span class="string">'nSlots'</span>, [], <span class="keyword">...</span>
    <span class="string">'nRoutes'</span>, [], <span class="keyword">...</span>
    <span class="string">'candidatePathOfsdk'</span>, [],<span class="keyword">...</span><span class="comment"> % path means (s,d,k);</span>
    <span class="string">'lengthOfPathOfsdk'</span>, [], <span class="keyword">...</span><span class="comment"> % cost of path (s,d,k);</span>
    <span class="string">'isPathOnsdkUseLink'</span>, [], <span class="keyword">...</span><span class="comment">  % path means (s,d,k);</span>
    <span class="string">'normDemandMatrix'</span>, [], <span class="keyword">...</span>
    <span class="string">'isEdgeUseSlot'</span>, [], <span class="keyword">...</span>
    <span class="string">'totalCapacityMatrix'</span>,[],<span class="keyword">...</span>
    <span class="string">'totalDemandMatrix'</span>, [],<span class="keyword">...</span>
    <span class="string">'STATUS_ACTIVE_CONNECTIONS'</span>, [], <span class="keyword">...</span><span class="comment"> activated by multi-commodity flows.</span>
    <span class="string">'STATUS_TRUE_CONNECTIONS'</span>, [], <span class="keyword">...</span><span class="comment"> all true if s\neq d.</span>
    <span class="string">'userParameters'</span>,[], <span class="keyword">...</span>
    <span class="string">'opticalBandNoOfSlot'</span>, [] <span class="keyword">...</span>
    );
UserNetstate            = default_netstate;

<span class="comment">% network basic parameter</span>
UserNetstate.nSlots     = nSlots;
UserNetstate.nRoutes    = nRoutes;

nNodes                  =  Networks.nNodes;
nEdges                  =  Networks.nEdges;

<span class="comment">% candidate routes' status initlization</span>
candidatePathOfsdk          = cell(nNodes,nNodes,nRoutes);
lengthOfCandidatePathOfsdk  = ones(nNodes,nNodes,nRoutes)*1e10;
costMatrix                  = fixCostMatrix(Networks.distanceMatrix);
<span class="keyword">for</span> s =1:nNodes
    <span class="keyword">for</span> d =1:nNodes
        <span class="keyword">if</span>(s==d)
            <span class="keyword">continue</span>;
        <span class="keyword">end</span>
        [Path,Cost] = kShortestPath(costMatrix,s,d, nRoutes);

        lengthOfCandidatePathOfsdk(s,d,1:length(Cost))  = Cost;
        candidatePathOfsdk(s,d,1:length(Path))          = Path;
    <span class="keyword">end</span>
<span class="keyword">end</span>
UserNetstate.candidatePathOfsdk  = candidatePathOfsdk;
UserNetstate.lengthOfPathOfsdk   = lengthOfCandidatePathOfsdk;

UserNetstate.isPathOnsdkUseLink = zeros(nNodes,nNodes,nRoutes, nEdges, <span class="string">'logical'</span>);
<span class="keyword">for</span> s =1:nNodes
    <span class="keyword">for</span> d =1:nNodes
        <span class="keyword">if</span>(s==d)
            <span class="keyword">continue</span>;
        <span class="keyword">end</span>
        <span class="keyword">for</span> k =1:nRoutes
            <span class="keyword">if</span> isempty(UserNetstate.candidatePathOfsdk{s,d,k})
                UserNetstate.isPathOnsdkUseLink(s,d,k,1:nEdges) = true;
            <span class="keyword">else</span>
                isLinkArray = convertVertexListToEdgeStatus(<span class="keyword">...</span>
                    UserNetstate.candidatePathOfsdk{s,d,k}<span class="keyword">...</span>
                    , Networks.edgeIndexMatrix<span class="keyword">...</span>
                    );
                UserNetstate.isPathOnsdkUseLink(s,d,k,logical(isLinkArray))<span class="keyword">...</span>
                    = true;
            <span class="keyword">end</span>
        <span class="keyword">end</span>
    <span class="keyword">end</span>
<span class="keyword">end</span>


nCommodity            = Commodity.nSize;

vec_srcNo_ofCommodity = Commodity.sourceNo;
vec_dstNo_ofCommodity = Commodity.destinationNo;
vec_flows_ofCommodity = (Commodity.flowSize)./sum(Commodity.flowSize);

demandRatioMatrix     = zeros(nNodes,nNodes);
<span class="keyword">for</span> iCommodity = 1:nCommodity
    demandRatioMatrix(vec_srcNo_ofCommodity(iCommodity), <span class="keyword">...</span>
        vec_dstNo_ofCommodity(iCommodity)) <span class="keyword">...</span>
        = vec_flows_ofCommodity(iCommodity);
<span class="keyword">end</span>
UserNetstate.normDemandMatrix = demandRatioMatrix;

UserNetstate.STATUS_TRUE_CONNECTIONS <span class="keyword">...</span>
    = logical(ones(nNodes,nNodes)-eye(nNodes,nNodes));

isActiveOnConnetions = false(nNodes,nNodes);
<span class="keyword">for</span> iCommodity = 1:nCommodity
    isActiveOnConnetions(vec_srcNo_ofCommodity(iCommodity),<span class="keyword">...</span>
        vec_dstNo_ofCommodity(iCommodity)) = true;
<span class="keyword">end</span>
UserNetstate.STATUS_ACTIVE_CONNECTIONS = isActiveOnConnetions;

UserNetstate.totalCapacityMatrix    = zeros(nNodes,nNodes); <span class="comment">% [Gbps]</span>

UserNetstate.totalDemandMatrix      = zeros(nNodes,nNodes); <span class="comment">% [Gbps]</span>

<span class="comment">% Edge slot status</span>
UserNetstate.isEdgeUseSlot          = zeros(nEdges, nSlots);

<span class="keyword">end</span>

<span class="keyword">function</span> minRequiredSNR_Matrix_kthRoute_atOpticalBand_atTRXBaud_withM = <span class="keyword">...</span>
    initializeRequiredSNR(<span class="keyword">...</span>
    minReq_Pathsdk_OpticalBand_TRx_TRxMod<span class="keyword">...</span>
    , CandidateModFormat<span class="keyword">...</span>
    )
[nNodes,~,nRoute,nOpticalbands,nTRxs,nTRxMods] <span class="keyword">...</span>
    = size(minReq_Pathsdk_OpticalBand_TRx_TRxMod);
minRequiredSNR_Matrix_kthRoute_atOpticalBand_atTRXBaud_withM <span class="keyword">...</span>
    = zeros(nNodes,nNodes,nRoute,nOpticalbands,nTRxs,nTRxMods);
<span class="keyword">for</span> s = 1 : nNodes
    <span class="keyword">for</span> d = 1 : nNodes
        <span class="keyword">if</span> s == d
            <span class="keyword">continue</span>;
        <span class="keyword">end</span>
        <span class="keyword">for</span> k = 1 : nRoute
            <span class="keyword">for</span> ob = 1 : nOpticalbands
                <span class="keyword">for</span> tb = 1 : nTRxs
                    <span class="keyword">for</span> m = 1 : nTRxMods
                        <span class="comment">% initialize the SNR;</span>
                        minRequiredSNR_Matrix_kthRoute_atOpticalBand_atTRXBaud_withM(s,d,k,ob,tb, m) <span class="keyword">...</span>
                            = CandidateModFormat(m).SNR * minReq_Pathsdk_OpticalBand_TRx_TRxMod(s,d,k,ob,tb, m);
                    <span class="keyword">end</span>
                <span class="keyword">end</span>
            <span class="keyword">end</span>
        <span class="keyword">end</span>
    <span class="keyword">end</span>
<span class="keyword">end</span>
<span class="keyword">end</span>

<span class="keyword">function</span> CapacityMatrix_kthRoute_atOpticalBand_atTRXBaud_withM <span class="keyword">...</span>
    = assignCapacityForAllCandidates(<span class="keyword">...</span>
    worstSNR_Pathsdk_atOpticalBand_atBaud_withM <span class="keyword">...</span>
    , minRequiredSNR_Pathsdk_atOpticalBand_atTRXBaud_withM<span class="keyword">...</span>
    , CandidateTransponder<span class="keyword">...</span>
    , CandidateModFormat<span class="keyword">...</span>
    )
<span class="comment">% Comment: uses the array class object instead of cell class object. 30th, Jun. 2023.</span>
[nNodes, ~, nRoutes, nOpticalBands, nTRxs, nTRxMods] =<span class="keyword">...</span>
    size(minRequiredSNR_Pathsdk_atOpticalBand_atTRXBaud_withM);

CapacityMatrix_kthRoute_atOpticalBand_atTRXBaud_withM =<span class="keyword">...</span>
    zeros(nNodes, nNodes, nRoutes, nOpticalBands, nTRxs, nTRxMods);
<span class="keyword">for</span> s = 1 : nNodes
    <span class="keyword">for</span> d = 1 : nNodes
        <span class="keyword">if</span> s == d
            <span class="keyword">continue</span>;
        <span class="keyword">end</span>
        <span class="keyword">for</span> k = 1 : nRoutes
            <span class="keyword">for</span> ob = 1 : nOpticalBands
                <span class="keyword">for</span> tb = 1 : nTRxs
                    <span class="keyword">for</span> m = 1 : nTRxMods
                        <span class="keyword">if</span>(worstSNR_Pathsdk_atOpticalBand_atBaud_withM(s,d,k,ob,tb,m) <span class="keyword">...</span>
                                &gt;= minRequiredSNR_Pathsdk_atOpticalBand_atTRXBaud_withM(s,d,k,ob,tb,m))
                            <span class="comment">% Capacity = Baud-Rate * SpectralEfficiency.</span>
                            CapacityMatrix_kthRoute_atOpticalBand_atTRXBaud_withM(s,d,k,ob,tb,m) = <span class="keyword">...</span>
                                CandidateTransponder(tb).GBaud * CandidateModFormat(m).spectralEfficiency;
                        <span class="keyword">end</span>
                    <span class="keyword">end</span>
                <span class="keyword">end</span>
            <span class="keyword">end</span>
        <span class="keyword">end</span>
    <span class="keyword">end</span>
<span class="keyword">end</span>
<span class="keyword">end</span>



<span class="keyword">function</span> showEdgeSpectrumGraph(<span class="keyword">...</span>
    isEdgeUseSlot<span class="keyword">...</span>
    , EdgeUseSlotWithOpticalBandNo<span class="keyword">...</span>
    , CandidateOpticalBand)
<span class="comment">% Description:</span>
<span class="comment">%  This function is used to show network spectrum usage</span>
<span class="comment">%   colored by optical band ID</span>
<span class="comment">%</span>
<span class="comment">%</span>
<span class="comment">% Created by Cao. CHEN</span>
<span class="comment">%  Date: 7th, Mar. 2023</span>
<span class="comment">% Comment: cell class--&gt;array class object;</span>


<span class="comment">% Basic Parameters</span>
NUMBER_OF_BANDS = length(CandidateOpticalBand);
NUMBER_OF_SLOTS = size(isEdgeUseSlot,2);

BandNameStr = getChar(CandidateOpticalBand, <span class="string">'name'</span>);

cmap_matrix = [<span class="keyword">...</span>
    1.0, 1.0, 1.0;  <span class="comment">% for occupied slot;</span>
    0.17, 0.17, 0.17; <span class="comment">% for 1st band;</span>
    0.33, 0.33, 0.33; <span class="comment">% for 2nd band;</span>
    0.5, 0.5, 0.5;    <span class="comment">% for 3rd band;</span>
    0.67, 0.67, 0.67; <span class="comment">% for 4th band;</span>
    0.83, 0.83, 0.83]; <span class="comment">% for 5th band;</span>

<span class="comment">% ==============================</span>
<span class="comment">% Conversion.</span>
<span class="comment">% ==============================</span>
ColoredLinkSlotBlock = isEdgeUseSlot.*EdgeUseSlotWithOpticalBandNo;

<span class="comment">% ==============================</span>
<span class="comment">% Show plots.</span>
<span class="comment">% ==============================</span>

figure(202), clf;
image(ColoredLinkSlotBlock+1), <span class="comment">% avoiding 0 and 1 take the same index.</span>
colormap(gcf, cmap_matrix);
xlabel(<span class="string">'Channel Number'</span>)
ylabel(<span class="string">'Link ID'</span>);
xlim([0.5, NUMBER_OF_SLOTS+0.5]);


<span class="comment">% Colorbar setting.</span>
colorbar(<span class="string">'peer'</span>,gca,<span class="string">'northoutside'</span>,<span class="keyword">...</span>
    <span class="string">'Ticks'</span>, 0.5 + [1:(NUMBER_OF_BANDS+2)],<span class="keyword">...</span>
    <span class="string">'Limits'</span>,[1 (NUMBER_OF_BANDS+2)], <span class="keyword">...</span>
    <span class="string">'TickLabels'</span>,[<span class="string">'Idle'</span>,strsplit(BandNameStr,{<span class="string">','</span>, <span class="string">' '</span>})]);


<span class="comment">% ==============================</span>
<span class="comment">% Export figure as .png file.</span>
<span class="comment">% ==============================</span>
figure(201), clf;
image(ColoredLinkSlotBlock+1), <span class="comment">% avoiding 0 and 1 take the same index.</span>
colormap(gcf, cmap_matrix);
axis <span class="string">off</span>;
xlim([0.5, NUMBER_OF_SLOTS+0.5]);
export_fig <span class="string">spectrum_usage_graph.png</span> <span class="comment">% famous open-source export function export_fig.m is required.</span>
<span class="keyword">end</span>

<span class="keyword">function</span> LightPathSet = addWavelength(<span class="keyword">...</span>
    LPonConfig, <span class="keyword">...</span>
    Repeated_Configurations, <span class="keyword">...</span>
    configNo_ofCh, <span class="keyword">...</span>
    ColorlessLightPath)
<span class="comment">% Description:</span>
<span class="comment">%</span>
<span class="comment">%   This function generates lightpaths by adding wavelength</span>
<span class="comment">%               to each **colored** configuration.</span>
<span class="comment">%</span>
<span class="comment">% ------------------------------</span>
<span class="comment">% Created by cchen, 15th, Jun. 2022</span>
<span class="comment">% ------------------------------</span>
<span class="comment">% Add output kidx.</span>
<span class="comment">% Modified by cchen, 22nd, Mar. 2023;</span>


<span class="comment">% ==============================</span>
<span class="comment">% Obtain parameters to be used;</span>
<span class="comment">% ==============================</span>
sefficiency_ofp         = ColorlessLightPath.capacity;
vec_uv_onp              = ColorlessLightPath.isPathUseEdges';
cost_p                  = ColorlessLightPath.cost;
vec_hops_onp            = ColorlessLightPath.hops;
vec_src_node_ofp        = ColorlessLightPath.sourceNo;
vec_dst_node_ofp        = ColorlessLightPath.destinationNo;
vec_kidx_ofp            = ColorlessLightPath.routeNo;
vec_nodePairNo_ofp      = ColorlessLightPath.nodePairNo;
vec_Mod_ofp             = ColorlessLightPath.transmissionModeNo;
vec_strPath_ofp         = ColorlessLightPath.strPath;
vec_ColoredConfigID_ofCh= configNo_ofCh;
MAXIMUM_LPs_CONFIGURE   = size(LPonConfig,1);
NoEdge                  = size(vec_uv_onp,1);

<span class="comment">% ==============================</span>
<span class="comment">% computation</span>
<span class="comment">% -     configure by appending;</span>
<span class="comment">% ==============================</span>
list_uv_ofp             = [];
list_cost_p             = [];
list_sefficiency_ofp    = [];
list_src_node_ofp       = [];
list_dst_node_ofp       = [];
list_kidx_ofp           = [];
list_nodePairNo_ofp     = [];
list_Ch_ofp             = [];
list_hop_ofp            = [];
list_Mod_ofp            = [];
list_strPath_ofp        = [];
<span class="keyword">for</span> idx_config = 1 : size(LPonConfig, 2)
    <span class="keyword">if</span> Repeated_Configurations(idx_config) &gt;= 1
        rep_current     = Repeated_Configurations(idx_config);
        <span class="keyword">for</span> idx_p = 1 : MAXIMUM_LPs_CONFIGURE
            <span class="keyword">if</span> LPonConfig(idx_p,idx_config) == 0
                <span class="keyword">continue</span>;
            <span class="keyword">end</span>
            pid         = LPonConfig(idx_p, idx_config);
            <span class="keyword">if</span> isempty(list_uv_ofp) ~= 0
                <span class="comment">% initialize for first time</span>
                list_uv_ofp          = [repmat(vec_uv_onp(1:NoEdge,pid), [1, rep_current])];
                list_cost_p          = [repmat(cost_p(pid), [1, rep_current])];
                list_hop_ofp         = [repmat(vec_hops_onp(pid), [1, rep_current])];
                list_sefficiency_ofp = [repmat(sefficiency_ofp(pid), [1, rep_current])];
                list_src_node_ofp    = [repmat(vec_src_node_ofp(pid), [1, rep_current])];
                list_dst_node_ofp    = [repmat(vec_dst_node_ofp(pid), [1, rep_current])];
                list_kidx_ofp        = [repmat(vec_kidx_ofp(pid), [1, rep_current])];
                list_nodePairNo_ofp  = [repmat(vec_nodePairNo_ofp(pid), [1, rep_current])];
                list_Ch_ofp          = [find(vec_ColoredConfigID_ofCh == idx_config)];
                list_Mod_ofp         = [repmat(vec_Mod_ofp(pid), [1, rep_current])];
                list_strPath_ofp     = [repmat(vec_strPath_ofp(pid), [1, rep_current])];
            <span class="keyword">else</span>
                <span class="comment">% otherwise, appending</span>
                list_uv_ofp          = [list_uv_ofp,          repmat(vec_uv_onp(1 : NoEdge, pid), [1, rep_current])];
                list_cost_p          = [list_cost_p,          repmat(cost_p(pid), [1, rep_current])];
                list_hop_ofp         = [list_hop_ofp,         repmat(vec_hops_onp(pid), [1, rep_current])];
                list_sefficiency_ofp = [list_sefficiency_ofp, repmat(sefficiency_ofp(pid), [1, rep_current])];
                list_src_node_ofp    = [list_src_node_ofp,    repmat(vec_src_node_ofp(pid), [1, rep_current])];
                list_dst_node_ofp    = [list_dst_node_ofp,    repmat(vec_dst_node_ofp(pid), [1, rep_current])];
                list_kidx_ofp        = [list_kidx_ofp,        repmat(vec_kidx_ofp(pid), [1, rep_current])];
                list_nodePairNo_ofp  = [list_nodePairNo_ofp,  repmat(vec_nodePairNo_ofp(pid), [1, rep_current])];
                list_Ch_ofp          = [list_Ch_ofp,          find(vec_ColoredConfigID_ofCh == idx_config)];
                list_Mod_ofp         = [list_Mod_ofp,         repmat(vec_Mod_ofp(pid), [1, rep_current])];
                list_strPath_ofp     = [list_strPath_ofp,     repmat(vec_strPath_ofp(pid), [1, rep_current])];
            <span class="keyword">end</span>
        <span class="keyword">end</span>
    <span class="keyword">end</span>
<span class="keyword">end</span>

<span class="comment">% ==============================</span>
<span class="comment">% Send to LightPathSet;</span>
<span class="comment">% ==============================</span>
n = length(list_Mod_ofp);
LightPathSet = LightPath(n,NoEdge);

LightPathSet.nSize = n;
<span class="keyword">for</span> pid = 1 : n
    <span class="comment">% Assign constant;</span>
    LightPathSet.transceiverNo(pid)        = 1;
    LightPathSet.nFrequencySlots(pid) = 1;

    <span class="comment">% Assign connection info;</span>
    LightPathSet.no(pid) = pid;
    LightPathSet.sourceNo(pid) = list_src_node_ofp(pid);
    LightPathSet.destinationNo(pid) = list_dst_node_ofp(pid);
    LightPathSet.routeNo(pid) = list_kidx_ofp(pid);
    LightPathSet.nodePairNo(pid) = list_nodePairNo_ofp(pid);
    LightPathSet.hops(pid) = list_hop_ofp(pid);

    LightPathSet.isPathUseEdges(pid, 1:NoEdge)= list_uv_ofp(1:NoEdge,pid);

    <span class="comment">% Physical parameters</span>
    LightPathSet.cost(pid)      = list_cost_p(pid);
    LightPathSet.capacity(pid)  = list_sefficiency_ofp(pid);
    LightPathSet.transmissionModeNo(pid) = list_Mod_ofp(pid);

    LightPathSet.wavelengthNo(pid) = list_Ch_ofp(pid);

    <span class="comment">% Others</span>
    LightPathSet.strPath(pid) = list_strPath_ofp(pid);
<span class="keyword">end</span>

<span class="keyword">end</span>

<span class="keyword">function</span> block_pNoSet_ofConfig = removeWavelength(uLightPathSet, ColorlessLightPathSet)
<span class="comment">%</span>
<span class="comment">%  Description:</span>
<span class="comment">%       pid(s,d,k,ch) -&gt; ___pid(s,d,k)___ --&gt; (pid,ch)</span>
<span class="comment">%  - pid(s,d,k,ch): uLightPathSet</span>
<span class="comment">%  - pid(s,d,k) : ColorlessLightPathSet</span>
<span class="comment">%  - (pid,ch) : block_pNoSet_ofConfig</span>
<span class="comment">%</span>
<span class="comment">%       remove wavelength of &lt;uLightPathSet&gt;,</span>
<span class="comment">%       i.e., configuring lightpath block as noted by ColorlessLightPathSet;</span>
<span class="comment">%</span>
<span class="comment">%  Detailed process:</span>
<span class="comment">%   The lightpaths computed by kSP-FF are separated by wavelength index.</span>
<span class="comment">%   They are converted into seperate wavelength configurations.</span>
<span class="comment">%   For each configuration, the source, destination, and route, i.e.,</span>
<span class="comment">%       (s,d,k), are kept except for wavlength index.</span>
<span class="comment">%</span>
<span class="comment">%   Maximum configurations of NoNodes*(NoNodes-1) are considered</span>
<span class="comment">%</span>
<span class="comment">% ==============================</span>
<span class="comment">% Derived from &lt;fun_convert_LPs2LPbysdk.m&gt;</span>
<span class="comment">% Author: cao chen;</span>
<span class="comment">%</span>
assert(isa(uLightPathSet, <span class="string">'LightPath'</span>),<span class="string">'error classes'</span>);
assert(isa(ColorlessLightPathSet, <span class="string">'LightPath'</span>),<span class="string">'error classes'</span>);

<span class="comment">% ==============================</span>
<span class="comment">% Obtain parameters to be used;</span>
<span class="comment">% ==============================</span>
MAX_LIGHTPATHS_CONFIGURE = size(ColorlessLightPathSet.isPathUseEdges,2);
MAX_WAVELENGTHS = max(uLightPathSet.wavelengthNo(:));

<span class="comment">% ==============================</span>
<span class="comment">% Computation</span>
<span class="comment">% ==============================</span>
block_pNoSet_ofConfig = zeros(MAX_LIGHTPATHS_CONFIGURE, MAX_WAVELENGTHS);
nLightPaths_ofConfig  = zeros(1, MAX_WAVELENGTHS);
<span class="keyword">for</span> iLightPathSet = 1:uLightPathSet.nSize

    assert(uLightPathSet.sourceNo(iLightPathSet)&gt;0, <span class="string">'We have not define it'</span>);

    <span class="keyword">if</span>(uLightPathSet.sourceNo(iLightPathSet)==0)
        <span class="keyword">break</span>;
    <span class="keyword">end</span>

    wChannel = uLightPathSet.wavelengthNo(iLightPathSet);
    idx  = <span class="keyword">...</span>
        find(<span class="keyword">...</span>
         ColorlessLightPathSet.sourceNo(:)     == uLightPathSet.sourceNo(iLightPathSet) <span class="keyword">...</span>
        &amp;ColorlessLightPathSet.destinationNo(:)== uLightPathSet.destinationNo(iLightPathSet) <span class="keyword">...</span>
        &amp;ColorlessLightPathSet.routeNo(:)      == uLightPathSet.routeNo(iLightPathSet) <span class="keyword">...</span>
        &amp;ColorlessLightPathSet.opticalBandNo(:)== uLightPathSet.opticalBandNo(iLightPathSet));
    <span class="keyword">if</span> idx ~= 0
        pid = ColorlessLightPathSet.no(idx);
        nLightPaths_ofConfig(wChannel) = nLightPaths_ofConfig(wChannel) + 1;
        block_pNoSet_ofConfig(nLightPaths_ofConfig(wChannel), wChannel) = pid;

        assert(nLightPaths_ofConfig(wChannel)&lt;=MAX_LIGHTPATHS_CONFIGURE, <span class="keyword">...</span>
            <span class="string">'Exceeding max lightpaths'</span>);
    <span class="keyword">end</span>
<span class="keyword">end</span>

<span class="keyword">end</span>

<span class="keyword">function</span> printTextToFile(fileName, headInfo, formatspec)
    fid = fopen(fileName,formatspec);
    fprintf(fid,<span class="string">'%s\n'</span>,headInfo);
    fclose(fid);
<span class="keyword">end</span>

<span class="keyword">function</span> handle = showNetworks(<span class="keyword">...</span>
    distanceMatrix<span class="keyword">...</span>
    , vec_longitude_ofn<span class="keyword">...</span>
    , vec_latitude_ofn)
<span class="comment">% Description:</span>
<span class="comment">%</span>
<span class="comment">% Plot Networks on the earth (with longitude, latitude, and adjacentMatrix)</span>
<span class="comment">%</span>
<span class="comment">% Author: cao.chen</span>
<span class="comment">% Date: Nov. 6th, 2023.</span>
<span class="comment">% ==============================</span>

nNodes          = size(distanceMatrix,1);
vec_degree_ofn  = computeNodeDegree(distanceMatrix);
nEdges          = sum(vec_degree_ofn)/2;

handle          = digraph(distanceMatrix);
<span class="comment">% ==============================</span>
<span class="comment">% Plot</span>
<span class="comment">% ==============================</span>
figure(1);
clf;
plot(handle,<span class="string">'XData'</span>,vec_longitude_ofn,<span class="string">'YData'</span>,vec_latitude_ofn);
title(sprintf(<span class="string">'Network graph with %d nodes, %d edges'</span>, nNodes,nEdges));
xlabel(<span class="string">''</span>);
ylabel(<span class="string">''</span>);
<span class="keyword">end</span>

<span class="keyword">function</span> deg = computeNodeDegree(adjacentMatrix)
<span class="comment">% Compute degree of nodes;</span>
deg = sum(adjacentMatrix,1);
<span class="keyword">end</span>

<span class="keyword">function</span> [ch, k] = <span class="keyword">...</span>
    revertChannelRoute(<span class="keyword">...</span>
    indexing<span class="keyword">...</span>
    , NUMBER_OF_CHANNELS<span class="keyword">...</span>
    , NUMBER_OF_ROUTES<span class="keyword">...</span>
    )
    <span class="comment">% This function takes channel first, and route second.</span>
    <span class="comment">%     For example,</span>
    <span class="comment">%     +----------------------+---------------------------+--+----------------------+----------------------------+</span>
    <span class="comment">%     |                      |     NUMBER_OF_ROUTES=7    |  |                      |     NUMBER_OF_ROUTES=7     |</span>
    <span class="comment">%     +----------------------+---+---+---+---+---+---+---+--+----------------------+---+---+---+----+---+---+---+</span>
    <span class="comment">%     |                      | 1 | 1 | 1 | 1 | 1 | 1 | 1 |  |                      | 0 | 1 | 2 | 3  | 4 | 5 | 6 |</span>
    <span class="comment">%     |                      +---+---+---+---+---+---+---+--+                      +---+---+---+----+---+---+---+</span>
    <span class="comment">%     |                      | 1 | 1 | 1 | 1 | 0 | 0 | 0 |  |                      | 7 | 8 | 9 | 10 | - | - | - |</span>
    <span class="comment">%     |                      +---+---+---+---+---+---+---+--+                      +---+---+---+----+---+---+---+</span>
    <span class="comment">%     | NUMBER_OF_CHANNELS=5 | 0 | 0 | 0 | 0 | 0 | 0 | 0 |  | NUMBER_OF_CHANNELS=5 | - | - | - | -  | - | - | - |</span>
    <span class="comment">%     |                      +---+---+---+---+---+---+---+--+                      +---+---+---+----+---+---+---+</span>
    <span class="comment">%     |                      | 0 | 0 | 0 | 0 | 0 | 0 | 0 |  |                      | - | - | - | -  | - | - | - |</span>
    <span class="comment">%     |                      +---+---+---+---+---+---+---+--+                      +---+---+---+----+---+---+---+</span>
    <span class="comment">%     |                      | 0 | 0 | 0 | 0 | 0 | 0 | 0 |  |                      | - | - | - | -  | - | - | - |</span>
    <span class="comment">%     +----------------------+---+---+---+---+---+---+---+--+----------------------+---+---+---+----+---+---+---+</span>
    <span class="comment">%</span>
    <span class="comment">%     Indexing: (ch,k): (ch-1) * NUMBER_OF_ROUTES + k</span>
    <span class="comment">%     Thus:</span>
    <span class="comment">%           ch = floor( (indexing-1) /NUMBER_OF_ROUTES ) + 1;</span>
    <span class="comment">%           k  = mod(indexing-1, NUMBER_OF_ROUTES)+1;</span>
    <span class="comment">%</span>
    ch = floor((indexing - 1) / NUMBER_OF_ROUTES ) + 1;
    k  = mod(indexing - 1, NUMBER_OF_ROUTES) + 1;
<span class="keyword">end</span>

<span class="keyword">function</span> [ch, k] = <span class="keyword">...</span>
    revertRouteChannel(<span class="keyword">...</span>
    indexing <span class="keyword">...</span>
    , NUMBER_OF_CHANNELS <span class="keyword">...</span>
    , NUMBER_OF_ROUTES<span class="keyword">...</span>
    )
    <span class="comment">% This function takes route first, and channel second.</span>
    <span class="comment">%     For example,</span>
    <span class="comment">%     +----------------------+---------------------------+--+----------------------+---------------------------+</span>
    <span class="comment">%     |                      |     NUMBER_OF_ROUTES=7    |  |                      |     NUMBER_OF_ROUTES=7    |</span>
    <span class="comment">%     +----------------------+---+---+---+---+---+---+---+--+----------------------+---+---+---+---+---+---+---+</span>
    <span class="comment">%     |                      | 1 | 1 | 0 | 0 | 0 | 0 | 0 |  |                      | 0 | 5 | - | - | - | - | - |</span>
    <span class="comment">%     |                      +---+---+---+---+---+---+---+--+                      +---+---+---+---+---+---+---+</span>
    <span class="comment">%     |                      | 1 | 1 | 0 | 0 | 0 | 0 | 0 |  |                      | 1 | 6 | - | - | - | - | - |</span>
    <span class="comment">%     |                      +---+---+---+---+---+---+---+--+                      +---+---+---+---+---+---+---+</span>
    <span class="comment">%     | NUMBER_OF_CHANNELS=5 | 1 | 0 | 0 | 0 | 0 | 0 | 0 |  | NUMBER_OF_CHANNELS=5 | 2 | - | - | - | - | - | - |</span>
    <span class="comment">%     |                      +---+---+---+---+---+---+---+--+                      +---+---+---+---+---+---+---+</span>
    <span class="comment">%     |                      | 1 | 0 | 0 | 0 | 0 | 0 | 0 |  |                      | 3 | - | - | - | - | - | - |</span>
    <span class="comment">%     |                      +---+---+---+---+---+---+---+--+                      +---+---+---+---+---+---+---+</span>
    <span class="comment">%     |                      | 1 | 0 | 0 | 0 | 0 | 0 | 0 |  |                      | 4 | - | - | - | - | - | - |</span>
    <span class="comment">%     +----------------------+---+---+---+---+---+---+---+--+----------------------+---+---+---+---+---+---+---+</span>
    <span class="comment">%</span>
    <span class="comment">%     Indexing funs:</span>
    <span class="comment">%           (ch,k) : (k-1) * NUMBER_OF_CHANNELS + ch;</span>
    <span class="comment">%     Thus:</span>
    <span class="comment">%           ch  = mod(indexing-1, NUMBER_OF_CHANNELS)+1;</span>
    <span class="comment">%           k   = floor( (indexing-1) /NUMBER_OF_CHANNELS) + 1;</span>
    ch  = mod(indexing - 1, NUMBER_OF_CHANNELS)+1;
    k   = floor( (indexing - 1) / NUMBER_OF_CHANNELS ) + 1;
<span class="keyword">end</span>
</pre><p class="footer"><br><a href="http://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2017a</a><br></p></div><!--
##### SOURCE BEGIN #####
function [varargout] = main(SimulationSetting)
%%
%
%  main: simulation setup, start compuation, and print and plot results.
%
%
%   Related paper : <Throughput Maximization in Multi-Band ...
%                       Optical Networks with Column Generation>
%
%  REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH
%  Output: 
% 
%   - 'varargout'
%       LightPathSet:                   lightpath information
%       isEdgeUseSlot:                  network block information
%       info:                           computation (time, results, ...)
% 
%   - log file:
%      'Results_heu_log.txt'              log of sequential algorithm
% 
%      'Results_Configuration.txt'        log of CG;
%      'Results_TableCG.txt'              log of detailed CG;
% 
%      'Results_LightPathSetPerCommodity' lightpath information
%      'Results_Table.txt'                log of current algorithm;
%
%  REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH
%   key parameters
%   SimulationSetting : [struct] user-given parameters;
%   Networks : [struct] basic network parameters, ...
%                     (nodes, topologies, distance matrix, etc.);
%   NetState : [struct] network state accompliashed with network, ...
%              including no. slots, LinkSlotBlock.
%   CandidateOpticalBand : [class 'OpticalBand' array] candidate bands, ...
%                       	e.g., CBand, LBand;
%   CandidateTransponder : [class 'Transceiver' array] candidate 
%                           transceivers at x GBd, including spectral 
%                           efficiency, SNR, bandwidth, etc.
%   CandidateModFormat : [class 'TransmissionMode' array] 
%                       transmission modes with different MFs and FECs, 
%                        e.g., PM_BPSK with 7% FEC overhead. We only show
%                        three properties, i.e., required SNR, capacity, 
%                        and transmission reach;
%   LightPathSet : [class  'LightPath'] lightpaths in a network.
%   MultiCommodityFlow : [class 'Demand']
%   MaxThroughputOptions : [class 'MaxOption'] user-defined options 
%                             during optimization.
%  REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH
% 
%   Note:
%  * 'Commodity/NodePair/Connection': a unique source and destination node 
%               pair, in a network. At most one entity exists for (s,d).
%  * 'demand/flow' : the possible user traffic [bps]. It can be 
%               repeated.
%  * 'CapacityMatrix' : this is initialized by regarding lightpath as 
%           p_{s,d,k,ob,tb,m}, so that transmission capacity of lightpath 
%           can be easily retrieved by indexing function.
%  * 'Channel/Slot/Wavelength' : They are totally equivalent in representing 
%           the basic spectrum unit in this project. 
%           Further refinements to distinguish channels and slots can be 
%           made, if we regard 'a' and 'a+1' slots as two channels, and 
%           'a,a+1' as a third channel.
% 
%  
%  Author: cao.chen
%  Log:
%  Derived from <simple_main_sequential_loadingMultiBandsv2.m>  -  22nd, Jun, 2023.
%  Review code. - 7, Nov. 2023.
%  Review code. - 11, Jan. 2024.
% 

%% main: load settings
ImportLib();
% ==============================
% Load settings
% ==============================
if nargin==0
    ConfigFile          = 'setup/SimulationSetup_EX4.yaml';
    SimulationSetting   = ReadYaml(ConfigFile);
end
networkTag          = SimulationSetting.network_tag;
rngSeed             = SimulationSetting.random_seed;

% ==============================
% Load optical bands
% ==============================
[TotalOpticalBand, nTotalOpticalBand, frequencySlots] = ...
    initializeOpticalBand(SimulationSetting);
keyName                       ='name';
[CandidateOpticalBand,nCandidateOpticalBand] = ...
    getClassByFields( ...
    SimulationSetting.widebandset ...
    , keyName ...
    , TotalOpticalBand ...
    );
% keyName                       = 'centerFrequency';
% CandidateOpticalBand          = sortClass(CandidateOpticalBand, keyName);
assert(...
    nCandidateOpticalBand == SimulationSetting.number_of_bands ...
    , 'MATLAB:main:UnMatchedSize'...
    , 'Wrong optical band setting');


% ==============================
% Load transceiver parameters
% ==============================
[TotalTransceiverAddNull, nTotalTransceiver] ...
            = initializeTransceiver(SimulationSetting);
keyName     = 'name';
[CandidateTransceiver, nCandidateTransceiver] ...
            = getClassByFields(...
            SimulationSetting.transponder_set ...
            , keyName ...
            , TotalTransceiverAddNull ...
            );
assert(...
    nCandidateTransceiver == SimulationSetting.number_of_transponder ...
    , 'MATLAB:main:UnMatchedSize'...
    , 'Wrong TRx setting'...
    );

% ==============================
% Load transmission modes
% ==============================
[TotalTransmissionMode, nTotalTransmissionMode] ...
            =  initializeTransmissionMode(SimulationSetting);
keyName     = 'name';
[CandidateTRxMod,nCandidateTRxMod] ...
            = getClassByFields(...
                SimulationSetting.transmission_mode_set ...
                , keyName ...
                , TotalTransmissionMode);
assert(...
    nCandidateTRxMod == SimulationSetting.number_of_transmission_modes...
    , 'MATLAB:main:UnMatchedSize'...
    , 'Wrong transission mode setting');

% % REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH
% #demo: fixed vs. flexible capacity;(try search 'demo');
% CandidateTRxMod = ...
%   getClassByFields('PM_QPSK', 'name', TotalTransmissionMode);
% nCandidateTRxMod = 1;
% % REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH
% ==============================
% Load traffic demand
% ==============================
MultiCommodityFlow ...
    = initializeCommodityFlows(SimulationSetting);

% ==============================
% Load networks
% ==============================
networkFileName     = ...
    sprintf('networks/mat_%s/%s.mat' ...
    , networkTag ...
    , networkTag);
load(networkFileName);
OpticalNetworks = initializeNetworks(...
    networkTag...
    , distanceSpanMatrix...
    , longitudeDegreeArray...
    , latitudeDegreeArray...
    ); % user-defined initialization function.
% showNetworks(logical(distanceSpanMatrix) ...
%     , longitudeDegreeArray ...
%     , latitudeDegreeArray); % show Networks if required.

% ==============================
% Load network state
% ==============================
netStateFileName = sprintf(...
    'Networks/mat_%s/netstate_%s%s.mat' ...
    , networkTag ...
    , networkTag ...
    , CandidateTransceiver.name ...
    );
if exist(netStateFileName)
    load(netStateFileName);
else %
    NetState = initializeNetworkState(OpticalNetworks...
        , SimulationSetting.candidate_routes ...
        , SimulationSetting.number_of_slots ...
        , MultiCommodityFlow);
    save(netStateFileName, 'NetState');
end

% ==============================
% Update LinkSlotBlock 
%   - Import optical band profile
%   - Update edgeSlotBlock (edge spectrum status, slot's optical band ID)
% ==============================
bandProfileSetting     = ReadYaml(SimulationSetting.wideband_file);
isEdgeUseOpticalBand   = initializeFiberOpticalBand( ...
    OpticalNetworks, CandidateOpticalBand, bandProfileSetting);
 
[CandidateOpticalBand] = assignSlotPosition(CandidateOpticalBand); 
[isEdgeUseSlot, opticalBandNoOfSlot] ...
                       = initializeEdgeSlot(...
                       isEdgeUseOpticalBand ...
                       , CandidateOpticalBand );
assert(...
    size(isEdgeUseSlot,2) == NetState.nSlots ...
    , 'MATLAB:main:UnMatchedSize' ...
    , 'wrong slots setting' ...
    );  % if slot number neq total given slots.

NetState.isEdgeUseSlot       = isEdgeUseSlot;
NetState.opticalBandNoOfSlot = opticalBandNoOfSlot;

%  - user parameter
NetState.userParameters      = []; % default parameter; 
% Note : This is a read/write interface. 
%       You can use it for debugging netstate-related parameters.
%   
% Example
%     ILP : null
%     SequentialHeu : searching index matrix for respective elements 
%                   of (s,d) on index (k,w);
%     CG : solving times, no. iterations, optimal bound of LP, etc. ...


% ==============================
% Capacity initialzation, assign 
%   - Baud*SE for p_{s,d,k,ob,tb,m}, if worstSNR >= REQSNR, 
%   - 0, otherwise.
% ==============================
% 
%   1. margin for path p_{s,d,k,ob,tb,m}, e.g., margin = 10*log(SNRREQ), considering
%       - a fixed margin for all;
%       - optical bands margin;

%   fixed margin
minReqMargin0 = 1;

%     optical band margin;
minReq1_Pathsdk_atOpticalBand_atTRx_withTRxMod = zeros(...
    OpticalNetworks.nNodes, ...
    OpticalNetworks.nNodes, ...
    NetState.nRoutes, ...
    nCandidateOpticalBand, ...
    nCandidateTransceiver, ...
    nCandidateTRxMod...
    );
% Note: we use '_' for naming.

for iOpticalBand = 1 : nCandidateOpticalBand
    thisBand = CandidateOpticalBand(iOpticalBand);
    minReq1_Pathsdk_atOpticalBand_atTRx_withTRxMod(...
        1:OpticalNetworks.nNodes, ... 
        1:OpticalNetworks.nNodes,...
        1:NetState.nRoutes,...
        iOpticalBand, ...
        1:nCandidateTransceiver, ...
        1:nCandidateTRxMod) ...
        = dB2lin(thisBand.SNRpenaltydB);
end
minReqFull_Pathsdk_atOpticalBand_atTRx_withTRxMod ... % linking all margins.
    = minReqMargin0 .* minReq1_Pathsdk_atOpticalBand_atTRx_withTRxMod; 

%   2. REQSNR : transforming margin into required SNR.
minRequiredSNR_Pathsdk_atOpticalBand_atTRXBaud_withM = ...
    initializeRequiredSNR(...
    minReqFull_Pathsdk_atOpticalBand_atTRx_withTRxMod, CandidateTRxMod);

%   3. Capacity initialzation, 
%       worstSNR: the SNR in worst-case transmission
SNRAfterFirstSpan = 120; % around 10^(20.7/10);
worstSNR_Pathsdk_atOpticalBand_atBaud_withM = ...
    SNRAfterFirstSpan ...
    ./ repmat(NetState.lengthOfPathOfsdk,... 
    1,1,1,nCandidateOpticalBand,nCandidateTransceiver,nCandidateTRxMod);

CapacityMatrix_kthRoute_atOpticalBand_atTRXBaud_withM = ...
    assignCapacityForAllCandidates(...
    worstSNR_Pathsdk_atOpticalBand_atBaud_withM, ...
    minRequiredSNR_Pathsdk_atOpticalBand_atTRXBaud_withM, ...
    CandidateTransceiver, ...
    CandidateTRxMod);

% ==============================
% Check before use
% ==============================
% check frequency slots from two sources :
%   - default no. slots (given SimulationSettings.frequency_slots).  
%   - transceiver's baud-rate.
for iTransceiver = 1 : nCandidateTransceiver
    thisTRx = CandidateTransceiver(iTransceiver);
    assert(thisTRx.GBaud == SimulationSetting.frequency_slots...
        , 'MATLAB:main:UnMatchedSize'...
        , 'Wrong frequency slots setting'...
        );
end


%% main: maximize network throughput
% 
% *Max Option settings*
% 

%  1. ILPmodel
algorithmName = 'ColumnGenerationHeu';
% e.g., ColumnGenerationHeu;SequentialLoadingHeu;ILPmodel 
MaxThroughputOptions = MaxOption(algorithmName);
MaxThroughputOptions = setSolverOption(MaxThroughputOptions ...
    , 'costLimit', SimulationSetting.limited_transceivers... 
    , 'rngSeed',   rngSeed...
    );
%%
% 
%     MaxThroughputOptions = setSolverOption(MaxThroughputOptions, ...
%         'algorithmOption.ILP_FeasibilityTol', SimulationSetting.ILP_FeasibilityTol, ...
%         'algorithmOption.ILP_OptimalityTol',  SimulationSetting.ILP_OptimalityTol,...
%         'algorithmOption.ILP_MIPGap',         SimulationSetting.ILP_mingap, ...
%         'algorithmOption.ILP_TimeLimit',      SimulationSetting.ILP_TimeLimit...
%         ); % For algorithmName = 'ILPmodel'
% 
%%

    MaxThroughputOptions = setSolverOption(MaxThroughputOptions, ...
        'algorithmOption.strategyLPConfigInitial', 'SequentialLoadingHeu', ...
        ...%'1LP per configuration', 'kSP-FF per configuration' 'SequentialLoadingHeu'
        'algorithmOption.RMPINTOptimalityTol',    SimulationSetting.rmpINT_optimality_tol,...
        'algorithmOption.RMPINTMIPgap',           SimulationSetting.rmpINT_mingap, ...
        'algorithmOption.RMPINTTimeLimit',        SimulationSetting.rmpINT_TimeLimit,...
        'algorithmOption.rmp_mingap',             SimulationSetting.rmp_mingap, ...
        'algorithmOption.rmp_TimeLimit',          SimulationSetting.rmp_TimeLimit, ...
        'algorithmOption.ConfigGroupSorting',     'number_of_Reps',...
        ... %  'number_of_FSs', 'number_of_LPs', 'number_of_Reps', 'randomly',
        'algorithmOption.ConfigGroupDirection',   'descend', ... 
        ... %  'ascend' or 'descend',
        'algorithmOption.ConfigSingleDirection',  'default',... 
        ... %  'randomly', 'default'
        'algorithmOption.pricing_optimality_tol', SimulationSetting.pricing_optimality_tol, ...
        'algorithmOption.pricing_mingap',         SimulationSetting.pricing_mingap...
        ); % For algorithmName = 'ColumnGenerationHeu'
    
%%  
% 
%     MaxThroughputOptions = setSolverOption(MaxThroughputOptions, ...
%         'algorithmOption.LoadingStrategy',      'kSP-FF', ...
%         ...%'FF-kSP', 'kSP-FF'
%         'algorithmOption.TerminateStrategy',    'First-blocking'...
%         ); % For algorithmName = 'SequentialLoadingHeu'
% 


%%
%  Add lightpath constraint if required; #temproaliry option
% 
%       MaxThroughputOptions.costLimit = 8000;
% 

fprintf(sprintf('%sN%dR%gTRx%g\n', networkTag, ...
    OpticalNetworks.nNodes,...
    rngSeed, ...
    CandidateTransceiver(1).GBaud));
[resultNetworkThroughput, NetState, LightPathSet, computationTime] = ...
    MaxThroughput(algorithmName, ...
    OpticalNetworks, ...
    NetState, ...
    CapacityMatrix_kthRoute_atOpticalBand_atTRXBaud_withM, ...
    MultiCommodityFlow, ...
    CandidateOpticalBand, ...
    CandidateTransceiver, ...
    CandidateTRxMod, ...
    MaxThroughputOptions);
% Input:
%  - OpticalNetworks:       network topology,
%  - NetState:              initial network state.
%  - MultiCommodityFlow:    demand profile
%  - CandidateTransceiver:  transceiver set,
%  - CandidateTRxMod:       transmission mode set,
%  - MaxThroughputOptions:  other simulation configurations,
%
% Output:
%  - lightpath,
%  - edge spectrum usage
%  - other infos.


% 
% 
%       Step 3: gathering information;
% 
% 
% ==============================
% Calculate metric;
% ==============================
assert(abs(resultNetworkThroughput ./ min(min( ...
    NetState.totalCapacityMatrix ./ NetState.normDemandMatrix)) - 1) <= 1e-6...
    , 'MATLAB:main:UnExpectedResults'...
    , 'Not coinciding throughput definition'...
    );
resultNoLightPaths      = LightPathSet.nSize;
resultNetworkCapacity   = sum(sum(NetState.totalCapacityMatrix));

% Export network fragmentation info.
bandwidthTypesSet       = unique( ...
    LightPathSet.nFrequencySlots(1 : resultNoLightPaths)); 
% Note: 1 for fixed-grid; >=1 for flex-grid;

resultSpectrumFragRatio = calculateNetworkFragmentationRatio(...
    NetState.isEdgeUseSlot, bandwidthTypesSet);

resultNetworkUtilizationRate = calculateNetworkOccupationRate(...
    NetState.isEdgeUseSlot);

% Average transmission capaicty per optical band.
resultCapacity_ofopticalband = ...
    groupSum( ...
    nonzeros(LightPathSet.capacity) ...
    , nonzeros(LightPathSet.opticalBandNo)...
    );
resultNoLightPaths_ofopticalband = ...
    groupSum( ...
    logical(nonzeros(LightPathSet.capacity)) ...
    , nonzeros(LightPathSet.opticalBandNo)...
    );


%% main: passing parameters

info                         = containers.Map;
info('RngSeed')              = rngSeed;
info('NetworkID')            = networkTag;
info('Gbaud')                = ...
    getNumeric(CandidateTransceiver, 'GBaud');
info('ModFormat')            = getChar(CandidateTRxMod, 'name');
info('Algorithms')           = algorithmName;
info('Time')                 = computationTime;
info('NetworkThroughput')    = resultNetworkThroughput;
info('NetwokCapacity')       = resultNetworkCapacity;
info('NoTransceivers')       = resultNoLightPaths;
info('LimitedTransceivers')  = MaxThroughputOptions.costLimit;
for iBand = 1 : nCandidateOpticalBand
    thisBand    = CandidateOpticalBand(iBand);
    info(sprintf(...
        '%sAvgCap',thisBand.name)) ...
                = resultCapacity_ofopticalband(iBand) ...
                / resultNoLightPaths_ofopticalband(iBand);
end

Astr            = [];
for iiBand = 1 : nCandidateOpticalBand
    thisBand    = CandidateOpticalBand(iiBand);
    Astr        = sprintf('%s%g ', Astr, ...
        thisBand.SNRpenaltydB);
end
info('MultiBand') = Astr;

info('SpectrumFragmentation')= resultSpectrumFragRatio;
info('NetworkUtilization')   = resultNetworkUtilizationRate;



%% main: print out information

% REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH
% Print Data as containers.map - for analyzing;
[nameRow,valueRow] = printContainer(info);
printTextToFile(...
    'Results_Table.txt'...
    , sprintf('%s\n%s', nameRow, valueRow) ...
    , 'A'); 

% REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH
% Print LightPath to text file
fileName = 'Results_LightPathSetPerCommodity.txt';

LightPathSetPerCommodity = repmat(...
    LightPath(round(NetState.nSlots/2),OpticalNetworks.nEdges) ...
    ,MultiCommodityFlow.nSize,1);
for iPath = 1 : LightPathSet.nSize
    pNo = iPath;
    cNo = LightPathSet.nodePairNo(pNo);
    LightPathSetPerCommodity(cNo) = ...
        addLightPath(LightPathSetPerCommodity(cNo),LightPathSet,pNo);
end
itemName = {...
    'capacity'...
    , 'cost'...
    , 'strPath'...
    , 'wavelengthNo'...
    , 'transceiverNo'...
    , 'transmissionModeNo'...
    }; 
printLightPathSetWithFlow(...
    LightPathSetPerCommodity, ...
    MultiCommodityFlow, ...
    itemName, ...
    fileName, 'w+');

%% main: plot result

edgeSlotBlock_coloredByOpticalBandNo = ...
    repmat(...
    NetState.opticalBandNoOfSlot'...
    , OpticalNetworks.nEdges...
    , 1 ...
    ); % give opticalbandNo.

isChannelUseSlots   = sparse(eye(NetState.nSlots,NetState.nSlots));
[isEdgeUseSlot]     = convertLightPath2EdgeSlot(...
    LightPathSet ...
    , isChannelUseSlots...
    );
assert(isequal(isEdgeUseSlot, NetState.isEdgeUseSlot) ... 
    , 'MATLAB:main:UnMatchedSize' ...
    , 'Check it again'...
    );

% showEdgeSpectrumGraph( ...%	Network status;
%     NetState.isEdgeUseSlot ...
%     , edgeSlotBlock_coloredByOpticalBandNo ...
%     , CandidateOpticalBand);
% 
% pause(0.1);
% figure(87),
% clf;
% imagesc(logical(isEdgeUseSlot), 'CDataMapping', 'scaled');colorbar
% title('Spectrum Usage Graph');
% xlabel('Slot');
% ylabel('Link');
% hold off;


%% main: deal with function output

nOutputs = nargout;
varargout= cell(1,nOutputs);

for k = 1:nOutputs
    switch(k)
        case 1
            varargout{1} = LightPathSet;
        case 2
            varargout{2} = isEdgeUseSlot;
        case 3
            varargout{3} = info;
        otherwise
            error('undefined');
    end
end
end
function [networkThroughput,NewNetstate,LightPathSet] = ...
    ColumnGenerationHeu(Networks, NetState, ...
    CapacityMatrix_kthRoute_atOpticalBand_atTRXBaud_withM, ...
    Commodity, CandidateOpticalBand,CandidateTransponder,...
    CandidateModFormat, MainOptions)
%% 
%         Procedure : Column Generation Approach for RWA and RWBA problems. 
% 
%         1: Initialize wavelength configuration set Omega_init
%         2: c_new <REPLACE_WITH_DASH_DASH null, Omega<REPLACE_WITH_DASH_DASHOmega_init.
%         3: Do
%         4:      Omega <== Omega and {c_new}
%         5:      Solve RMP(Omega) with relaxing variables, z_c\in R_{\geq 0}
%         6:      Choose a column c_new via pricing problem(s)
%         7: While Reduced cost in line 6 is positive
%         8: Solve RMP(Omega) with integer variables, z_c\in Z_{\geq 0}
%         9: Assign a wavelength to each configuration
% 
%%
% 
%  Author: cao chen (chen.cao{at}sjtu.edu.cn; chen_cao_{at}hotmail.com)
%  Date: Nov. 7, 2023.
% 

assert(strcmp(MainOptions.algorithmName,'ColumnGenerationHeu')...
    , 'MATLAB:ColumnGenerationHeu:UnMatchedName'...
    , 'Algorithm name does not match'...
    );
%% 
NUM_COMMODITY                = Commodity.nSize;
NUM_SLOT                     = NetState.nSlots;
NUM_ROUTE                    = NetState.nRoutes;
NUM_NODE                     = Networks.nNodes;
NUM_EDGE                     = Networks.nEdges;
NUM_TRANSPONDER              = length(CandidateTransponder);
NUM_MODULATIONFORMATS        = length(CandidateModFormat);
NUM_OPTICALBAND              = length(CandidateOpticalBand);
MAXIMUM_ITERATION            = MainOptions.algorithmOption.CG_NoLoops;
vec_bandNo_ofCh              = NetState.opticalBandNoOfSlot;

vec_limitedwavelengths_onbands =  getNumeric(CandidateOpticalBand ...
    , 'nFrequencySlots');
MAX_TRANSCEIVER              = MainOptions.costLimit;



%% CG: pre-calculate ColorLessLightPathSet
%  Pre-calculate ColorLessLightPathSet _p(s,d,k,ob)_
%   - This set shows all possible lightpaths within a configuration.
%   - Default transceiverNo 1 

MAX_LIGHTPATH_CONFIGURE      = Networks.nEdges;
% since ideally, one lightpath - one hop.
MAX_POSSIBILITY_PERCONFIG    = NUM_COMMODITY * NUM_ROUTE * NUM_OPTICALBAND;
 
assert(...
    NUM_TRANSPONDER == 1 ...
    , 'MATLAB:ColumnGenerationHeu:FixGrid'...
    , 'Cannot support two transceivers now'...
    );
%% 
% *Create colorless lightpath set*
% 
ColorlessLightPathSet = ...
    createColorlessLightPath(...
    LightPath(MAX_POSSIBILITY_PERCONFIG, NUM_EDGE)...
    , Commodity ...
    , NetState...
    );
 
% Assign capacity with highest modulation format
for iPath = 1 : ColorlessLightPathSet.nSize
    pNo = iPath;
    tb  = 1; 
    [maxCapacity, targetMod] = max(...
        CapacityMatrix_kthRoute_atOpticalBand_atTRXBaud_withM(...
        ColorlessLightPathSet.sourceNo(pNo), ...
        ColorlessLightPathSet.destinationNo(pNo), ...
        ColorlessLightPathSet.routeNo(pNo), ...
        ColorlessLightPathSet.opticalBandNo(pNo), ...
        tb, ... ColorlessLightPathSet.transceiverNo(pid), ...
        1:NUM_MODULATIONFORMATS)...
        );
    ColorlessLightPathSet.capacity(pNo) ...
        = maxCapacity;
    ColorlessLightPathSet.transmissionModeNo(pNo) ...
        = targetMod;
end 
 
%% CG-step 1: initialize configuration

algorithmEventInitialize = tic;
switch MainOptions.algorithmOption.strategyLPConfigInitial
    case '1LP per configuration'
        
        LP_Config_Block = zeros(MAX_LIGHTPATH_CONFIGURE, NUM_COMMODITY);
        for iConfig = 1 : NUM_COMMODITY
            for jPath = 1 : ColorlessLightPathSet.nSize
                if iConfig == ColorlessLightPathSet.connectionNo(jPath)
                    LP_Config_Block(1, iConfig) = jPath;
                    break;
                end
            end
        end
        
    case 'SequentialLoadingHeu'
        % ==============================
        % Set initial algorithm options;
        % ==============================
        nInitialConfig  = min(NUM_COMMODITY,NUM_SLOT);
        % We consider the minimum number of configurations as NUM_COMMODITY, 
        % This is for least flow between any node pairs in the network.
         
        InitialOptions  = MaxOption('SequentialLoadingHeu');
        InitialOptions  = setSolverOption(InitialOptions, ...
            'algorithmOption.algorithmName',    'SequentialLoadingHeu', ...
            'algorithmOption.LoadingStrategy',  'kSP-FF',...'kSP-FF', 'FF-kSP'
            'algorithmOption.TerminateStrategy','All-blocking');
        
        InitialNetstate                 = NetState;
        InitialNetstate.isEdgeUseSlot   = zeros(NUM_EDGE, nInitialConfig);
        InitialNetstate.nSlots          = nInitialConfig;
        InitialNetstate.userParameters  = zeros(NUM_NODE, NUM_NODE); 
        % searching idx (for initial optimization);
        % ==============================
        % Optimize
        % ==============================
        [~, ~,uLightPathSet] = SequentialLoadingHeu(... 
            Networks, ...
            InitialNetstate, ...
            CapacityMatrix_kthRoute_atOpticalBand_atTRXBaud_withM, ...
            Commodity, ...
            CandidateOpticalBand, CandidateTransponder,...
            CandidateModFormat,InitialOptions);
        % u means 'user';
        % ==============================
        % remove channel information, LightPaths REPLACE_WITH_DASH_DASH> Config;
        % ==============================
        LP_Config_Block             = zeros(...
                                        MAX_LIGHTPATH_CONFIGURE,...
                                        nInitialConfig...
                                        );
        blockInitial_pNo_ofConfig   = removeWavelength(...
                                        uLightPathSet ...
                                        , ColorlessLightPathSet ...
                                        );
        LP_Config_Block(1 : MAX_LIGHTPATH_CONFIGURE,1 : nInitialConfig)=...
                                        blockInitial_pNo_ofConfig(...
                                        1 : MAX_LIGHTPATH_CONFIGURE ...
                                        , 1 : nInitialConfig...
                                        );
    otherwise
        error('non-specified StrategyLPConfigInitial');
end
timeInitialize = toc(algorithmEventInitialize);



%%  CG-step 2: process new configuration and current set
% 
% Wavelength configuration properties
% 
% * nSize: [1]
% * isActive: [1] * |Omega|
% * no: [1] * |Omega|
% * opticalBandNo: [1] * |Omega|
% * nFrequencySlot: [1] * |Omega|
% * nLightPath: [1] * |Omega|
% * lightPathNoSet: MAX_LIGHTPATHS_PERCONFIG * |Omega|
% * capacity_perCommodity: |Commodity| * |Omega|
%
CandidateWaveConfigSet = ...
    WaveConfig(1e3, ...
    struct(...
    'MAXIMUM_LIGHTPATHS_CONFIGURE', MAX_LIGHTPATH_CONFIGURE...
    , 'NUM_COMMODITY',              NUM_COMMODITY...
    )...
    );
%  configure by the known lightpaths.
CandidateWaveConfigSet = ConfigureParameters(CandidateWaveConfigSet, ...
    [1:size(LP_Config_Block,2)], ...
    LP_Config_Block,...
    ColorlessLightPathSet);
%% CG-step 3: Loop begins
OptionsForRMP = sdpsettings('solver', 'gurobi'...
    , 'verbose',            0 ...
    , 'cachesolvers',       1 ...
    , 'gurobi.MIPGap',      MainOptions.algorithmOption.rmp_mingap...
    , 'debug',              0 ...
    , 'gurobi.TimeLimit',   MainOptions.algorithmOption.rmp_TimeLimit...
    );

% - Simulation: ILP option
OptionPricing.OptimalityTol = MainOptions.algorithmOption.pricing_optimality_tol;
OptionPricing.MIPgap        = MainOptions.algorithmOption.pricing_mingap;



algorithmEventCGLoop = tic;

% ==============================
% Create plot handles
% ==============================
objRMP_ofiter     = NaN(MAXIMUM_ITERATION, 1);
objPricing_ofiter = NaN(MAXIMUM_ITERATION, 1);
figure(1); 
hRMP = plot(objRMP_ofiter,'YDataSource','objRMP_ofiter');
xlabel('# iterations');
ylabel('Max. Throughput [Gbps]');
title('Varation of Max. Throughput [Gbit/s]');

figure(2); hPricing = plot(objPricing_ofiter,'YDataSource','objPricing_ofiter');
xlabel('# iterations');
ylabel('Reduced cost (in Pricing Problem)');
title('Varation of Reduced Cost');

%=================================
% Create empty configuration
%=================================
ConfigNew               = [];
Capacity_oncommodity    = [];
idxBestPricing          = [];
for iIteration = 1 : MAXIMUM_ITERATION
    %================================= 
    %     Add a new configuration;
    %================================= 
    curNo                  = CandidateWaveConfigSet.nSize;
    CandidateWaveConfigSet = ConfigureParameters(CandidateWaveConfigSet, ...
                                                    [curNo+1], ...
                                                    ConfigNew,...
                                                    ColorlessLightPathSet...
                                                    );
    %=================================
    %          Restricted Master Problem (printing reduced cost).
    %=================================
    % fprintf('At iteration %d ==============================\n'...
    %           , count_iteration);
    % fprintf('**(Restricted Master Problem)\n');
    [obj_RestrictedMasterProblem_LP, ...
        ~, ...
        dual_commodity, ...
        dual_onLimitedTransceiver, ...
        dual_onLimitedWavelength, ...
        ReducedCost_perConfig] = solveRMP( ...
                                    CandidateWaveConfigSet...
                                    , Commodity ...
                                    , vec_limitedwavelengths_onbands...
                                    , MAX_TRANSCEIVER...
                                    , OptionsForRMP...
                                    );

    DualVariables = struct(...
        'dual_commodity',            dual_commodity, ...
        'dual_onLimitedTransceiver', dual_onLimitedTransceiver, ...
        'dual_onLimitedWavelength',  dual_onLimitedWavelength...
        );
    
    % ==============================
    %  Pricing Problem
    % :: Maximum Weight Independent Set Problem.
    % ==============================
    %     fprintf('**(Pricing problem)==============================\n');
    OBJ_REDUCED_COST = zeros(NUM_OPTICALBAND, 1);
    ConfigNewPricing = zeros(MAX_LIGHTPATH_CONFIGURE, NUM_OPTICALBAND);
    for b = 1 : NUM_OPTICALBAND
        % ==============================
        % Pricing by ILP
        % ==============================
        % [ConfigNew, obj_PricingProblem, NoLPsConfigNew] = ILP_ForPricingMultiBand( ...
        %     OptionPricing...
        %     ,ColorlessLightPathSet...
        %     ,b... % choose LightPaths on ob-th optical band.
        %     ,Commodity...
        %     ,DualVariables ...
        %     ,Networks...
        %     );
        % ==============================
        % Pricing by heuristics
        % ==============================
        [ConfigNew, obj_PricingProblem, NoLPsConfigNew] = ...
            HEU1_ForPricingMultiBand( ...
            OptionPricing, ...
            ColorlessLightPathSet, b, ...
            Commodity, ...
            DualVariables...
            );
        OBJ_REDUCED_COST(b) = obj_PricingProblem;
        ConfigNewPricing(1 : NoLPsConfigNew, b) = ...
                                    ConfigNew(1 : NoLPsConfigNew);
    end
    % ==============================
    %     Find the most promising configuration;
    % - idxBestPricing     : optical band no.
    % - ConfigNew          : lightPaths in this configuration;
    % ==============================
    [~,idxBestPricing] = max(OBJ_REDUCED_COST);
    if OBJ_REDUCED_COST(idxBestPricing)<=1e-4
        fprintf('iteration ends with no new optimal columns\n');
        break;
    end
    ConfigNew = ConfigNewPricing(1 : MAX_LIGHTPATH_CONFIGURE,idxBestPricing);
    
    % ==============================
    %     Plot convergence performance
    objRMP_ofiter(iIteration)    = obj_RestrictedMasterProblem_LP;
    objPricing_ofiter(iIteration)= OBJ_REDUCED_COST(idxBestPricing);
    refreshdata(hRMP,'caller'); drawnow;
    refreshdata(hPricing,'caller'); drawnow;
    pause(.05);
    % ==============================
end

timeCGLoop = toc(algorithmEventCGLoop);


%% CG-step 4: RMP with integer constraints
% 
%  Simulation: ILP option for RMP_INT
% 
OptionRMPINT.OptimalityTol = MainOptions.algorithmOption.RMPINTOptimalityTol;
OptionRMPINT.MIPgap        = MainOptions.algorithmOption.RMPINTMIPgap;
OptionRMPINT.TimeLimit     = MainOptions.algorithmOption.RMPINTTimeLimit;
eventRMPINT                = tic;
[obj_RestrictedMasterProblem, rep_Config] = solveRMP_INT( ...
    OptionRMPINT ... 
    , CandidateWaveConfigSet...
    , Commodity ...
    , vec_limitedwavelengths_onbands ...
    , MAX_TRANSCEIVER...
    );

networkThroughput  = obj_RestrictedMasterProblem;
rep_Config         = round(rep_Config); % float if large solution gap

timeRMPINT          = toc(eventRMPINT);

%% CG-step 5: configure wavelength
% *Sort configurations*
% 
PackOption = struct( ...
    'isGroup',      true, ...
    'direction',    'descend', ...'descend', 'ascend'
    'basis',        'numberOfRepetitions'...
    ...'numberOfRepetitions',
    ...'numberOfFrequencySlots',
    ...'numberOfLightPaths',
    ...'random'
    );

[vec_ColoredConfigID_ofCh] = packConfiguration(CandidateWaveConfigSet, ...
    rep_Config, PackOption);
            
% ============================== 
% Processing lightpath;
% ============================== 
LP_Config_Block = CandidateWaveConfigSet.lightPathNoSet(1:MAX_LIGHTPATH_CONFIGURE,...
    1:CandidateWaveConfigSet.nSize);
% add color : configuration to lightpath;
LightPathSet    = addWavelength(...
    LP_Config_Block...
    , rep_Config...
    , vec_ColoredConfigID_ofCh...
    , ColorlessLightPathSet...
    );
for iiPath = 1 : LightPathSet.nSize
    pNo         = iiPath;
    wChannel    = LightPathSet.wavelengthNo(pNo);
    
    LightPathSet.opticalBandNo(pNo) = vec_bandNo_ofCh(wChannel);
end
Z_Ch_useslots   = eye(NUM_SLOT,NUM_SLOT);
[edgeSlotBlock] = convertLightPath2EdgeSlot(...
    LightPathSet ...
    , Z_Ch_useslots);
%% CG-step 6: data post-processing
% ============================== 
% Obtain neccesary parameter settings;
% ============================== 
nConfigs        = CandidateWaveConfigSet.nSize;
nPath_perConfig = double(CandidateWaveConfigSet.nLightPath(1 : nConfigs));
assert(...
    nPath_perConfig(:)'*rep_Config(:) == LightPathSet.nSize...
    , 'MATLAB:ColumnGenerationHeu:UnMachedSize'...
    , 'They must be same'...
    );
assert(...
    numel(rep_Config) == nConfigs...
    , 'MATLAB:ColumnGenerationHeu:UnExpectedValues'...
    , 'They must be in the same size'...
    );
assert(...
    sum(rep_Config(:)) <= sum(vec_limitedwavelengths_onbands)...
    , 'MATLAB:ColumnGenerationHeu:UnExpectedValues'...
    , 'Wrong wavelength'...
    );

vec_bandNo_onconfigc = CandidateWaveConfigSet.opticalBandNo(1:nConfigs);

capacityMatrix_commodityi_onconfigc = ...
    CandidateWaveConfigSet.capacity_perCommodity(...
        1 : NUM_COMMODITY, ...
        1 : nConfigs...
    );

%=================================
% Processing and passing parameters.
%=================================
% no. LPs per optical band
vec_nLPs_ofband = groupSum(...
    nPath_perConfig(:).*rep_Config(:)...
    , vec_bandNo_onconfigc...
    );
% total LPs' capacity per optical band
vec_LPCap_ofbands = groupSum(...
    sum(capacityMatrix_commodityi_onconfigc,1)'.*rep_Config(:)...
    , vec_bandNo_onconfigc...
    );

% ==============================
% Update state
% ==============================

NewNetstate        = NetState; 
connectionCapaicty = zeros(NUM_NODE,NUM_NODE);
for iCommodity = 1 : NUM_COMMODITY
    src                         = Commodity.sourceNo(iCommodity);
    dst                         = Commodity.destinationNo(iCommodity);    
    connectionCapaicty(src,dst) = ...
        capacityMatrix_commodityi_onconfigc(iCommodity, 1 : nConfigs) ...
        * rep_Config;
end
NewNetstate.totalCapacityMatrix = connectionCapaicty;

UserParameters = struct(...
    'obj_RMP_LP',   obj_RestrictedMasterProblem_LP, ...
    'NoConfigs',    nConfigs, ...
    'tCG_ofHeuInit',timeInitialize, ...
    'tCG_iteration',timeCGLoop, ...
    'tCG_INT',      timeRMPINT...
    );
NewNetstate.userParameters = UserParameters;


NewNetstate.isEdgeUseSlot = edgeSlotBlock;


%%
% 
% *Print*
% 
% * print configurations to text file;
% * print selected information to text file;
% 

fprintf('Average LP''s on Optical Bands = [%s] \n', ...
    printArray(vec_LPCap_ofbands ./ vec_nLPs_ofband));
fprintf('Column Generation (init.= %g, iter. = %g seconds, INT = %g seconds). \n',...
    timeInitialize, timeCGLoop, timeRMPINT); 

% print configurations to text file;
fileName = 'Results_Configuration.txt';
headInfo = sprintf(...
    'Objective: maximum network throughput = %g, no. lightpaths=%d, no. configurations=%d (no. configuration types= %d)\n', ...
    obj_RestrictedMasterProblem, ...
    LightPathSet.nSize, ...
    CandidateWaveConfigSet.nSize, ...
    length(nonzeros(rep_Config)));
printTextToFile(fileName, headInfo, 'w+');
printConfiguration(...
    CandidateWaveConfigSet...
    , fileName ... 
    , rep_Config ... 
    , ColorlessLightPathSet);

% ==============================
% print selected information to text.
% ==============================



CG_DataRow                      = containers.Map;
CG_DataRow('InitialAlgorithm')  = ...
    MainOptions.algorithmOption.strategyLPConfigInitial;
CG_DataRow('NetworkTESTID')     = Networks.tag;
CG_DataRow('NetworkThroughput') = networkThroughput;
CG_DataRow('RngSeed')           = MainOptions.rngSeed;
CG_DataRow('obj_RMP_LP')        = NewNetstate.userParameters.obj_RMP_LP;
CG_DataRow('NoConfigs')         = NewNetstate.userParameters.NoConfigs;
CG_DataRow('tCG_ofHeuInit')     = num2str(NewNetstate.userParameters.tCG_ofHeuInit);
CG_DataRow('tCG_iteration')     = num2str(NewNetstate.userParameters.tCG_iteration);
CG_DataRow('tCG_INT')           = num2str(NewNetstate.userParameters.tCG_INT);

[nameRow, valueRow]             = printContainer(CG_DataRow);

printTextToFile(...
    'Results_TableCG.txt'...
    , sprintf('%s\n%s', nameRow, valueRow)...
    , 'A'); % 'A' is important for parallel computation;

end

function [NetworkThroughput, NewNetState, LightPathSet, ComputationTime]=...
    MaxThroughput(...
    func...
    , OpticalNetworks ...
    , NetState ...
    , capacityMatrix_kthRoute_atOpticalBand_atTRXBaud_withM ...
    , Commodity ...
    , CandidateOpticalBand ...
    , CandidateTransponder ...
    , CandidateModFormat ...
    , Options...
    )

% Check number of input arguments
try 
    narginchk(9,9);
catch ME
    error(ME.message);
end

if(iscell(func))
    fun = func{1};
elseif(isa(func,'char')) % for string;
    fun = str2func(func);
else
    fun = func;
end

% capacity scaling;
scalingFactor = Options.capacityScalingFactor; 
% REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH
% scalingFactor = 1e-3*0+1; % #demo: scaling if neccessary;
% REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH
capacityMatrix_kthRoute_atOpticalBand_atTRXBaud_withM = ...
    capacityMatrix_kthRoute_atOpticalBand_atTRXBaud_withM  ...
    .* scalingFactor;

Alg = tic;
switch Options.algorithmName
    case 'ColumnGenerationHeu'
        [NetworkThroughput,NewNetState,LightPathSet] = fun(...
            OpticalNetworks, NetState, ...
            capacityMatrix_kthRoute_atOpticalBand_atTRXBaud_withM, ...
            Commodity, ...
            CandidateOpticalBand,CandidateTransponder,CandidateModFormat,Options); 
        NewNetState.userParameters.obj_RMP_LP= ...% special for user_parameters.
            NewNetState.userParameters.obj_RMP_LP*1/scalingFactor; 
    case 'SequentialLoadingHeu' 
        NetState.userParameters = zeros(OpticalNetworks.nNodes,...
            OpticalNetworks.nNodes); % searching idx <= 0 ;
        [NetworkThroughput,NewNetState,LightPathSet] = fun(...
            OpticalNetworks, NetState, ...
            capacityMatrix_kthRoute_atOpticalBand_atTRXBaud_withM, ...
            Commodity, ...
            CandidateOpticalBand,CandidateTransponder,CandidateModFormat,Options);
    case 'ILPmodel' 
        [NetworkThroughput,NewNetState,LightPathSet] = fun(...
            OpticalNetworks, NetState, ...
            capacityMatrix_kthRoute_atOpticalBand_atTRXBaud_withM, ...
            Commodity, ...
            CandidateOpticalBand,CandidateTransponder,CandidateModFormat,Options); 
    otherwise
        error('Not defined');
end
ComputationTime         = toc(Alg);

% capacity re-scaling for all parameters related to the capacity;
NetworkThroughput       = NetworkThroughput * 1./scalingFactor;
NewNetState.totalCapacityMatrix = ...
    NewNetState.totalCapacityMatrix * 1/scalingFactor;
LightPathSet.capacity   = LightPathSet.capacity * 1/scalingFactor;


% Output basic information (results, run time, etc.)
thisAlgorithmName       = Options.algorithmOption.algorithmName;
if(strcmp(Options.algorithmName, 'SequentialLoadingHeu'))
    thisAlgorithmName   = sprintf('%s', ...
        Options.algorithmOption.LoadingStrategy);
end
fprintf('t(%s): %g seconods\n', thisAlgorithmName, ComputationTime);
fprintf('NetworkThroughput =%g Pbps, No. Transceivers =%d\n', ...
    1e-6*NetworkThroughput, LightPathSet.nSize);

end


function [networkThroughput, NewNetState, LightPathSet] = ...
    ILPmodel(...
    Networks ...
    , Netstate ...
    , capacityMatrix_kthRoute_atOpticalBand_atTRXBaud_withM ...
    , Commodity ...
    , CandidateOpticalBand ...
    , CandidateTransceiver ...
    , CandidateModFormat ...
    , MainOptions...
    )

% Check Algorithm's name;
assert(strcmp(MainOptions.algorithmName, 'ILPmodel') ...
    , 'Algorithm name does not match');


% ==============================
% Fast parameter extraction
% ==============================
NUM_NODE                     = Networks.nNodes;
NUM_EDGE                     = Networks.nEdges;
NUM_ROUTE                    = Netstate.nRoutes;
NUM_CHANNEL                  = Netstate.nSlots;
NUM_SLOT                     = Netstate.nSlots;

EXCLUDE_IDDENTICALPAIR       = Netstate.STATUS_TRUE_CONNECTIONS;
normalizedDemand             = Netstate.normDemandMatrix;
bin_sdk_atl                  = Netstate.isPathOnsdkUseLink;
vec_opticalBandNo_ofCh       = Netstate.opticalBandNoOfSlot;

NUM_TRANSPONDER              = length(CandidateTransceiver);
NUM_MODULATIONFORMAT         = length(CandidateModFormat);
NUM_COMMODITY                = Commodity.nSize;
limitedTransceivers          = MainOptions.costLimit;


%% ILP-initialize parameters
% 
%  Lightpath capacity conversion
% 
capacityMatrix_kthRoute_atCh = zeros(NUM_NODE, NUM_NODE, NUM_ROUTE, NUM_CHANNEL);
targetMod_kthRoute_atCh      = zeros(NUM_NODE, NUM_NODE, NUM_ROUTE, NUM_CHANNEL);
for ch = 1:NUM_CHANNEL
    idx_ob      = vec_opticalBandNo_ofCh(ch);
    [cap,cM]    = max(max( ...
        capacityMatrix_kthRoute_atOpticalBand_atTRXBaud_withM(...
        1 : NUM_NODE...
        , 1 : NUM_NODE ...
        , 1 : NUM_ROUTE...
        , idx_ob ...
        , 1 : NUM_TRANSPONDER...
        , 1 : NUM_MODULATIONFORMAT...
        )...
        ,[],5)...
        ,[],6);
    targetMod_kthRoute_atCh(1:NUM_NODE,1:NUM_NODE,1:NUM_ROUTE,ch) = cM;
    capacityMatrix_kthRoute_atCh(1:NUM_NODE,1:NUM_NODE,1:NUM_ROUTE,ch) = cap;
end

%% ILP-step1: define variable
eventILP                = tic;

var_bin_sdk_atCh        = binvar(NUM_NODE,NUM_NODE,NUM_ROUTE,NUM_CHANNEL,'full');
var_Throughput          = sdpvar(1,1);
var_Throughput_matrix   = sdpvar(NUM_NODE,NUM_NODE,'full');

%% ILP-step2: add constraints

Constraints = [];
% Limited transceivers;
Constraints = [Constraints, ...
    (sum(sum(sum(sum(var_bin_sdk_atCh))))<=limitedTransceivers):'Limited Transceivers'];

% Constraints (1): for maximum capacity; this is easier to understand (may be not very fast)
var_Capacity_Matrix = sum(sum(sum( ...
    capacityMatrix_kthRoute_atCh(:,:,1:NUM_ROUTE,1:NUM_CHANNEL).* var_bin_sdk_atCh(:,:,1:NUM_ROUTE,1:NUM_CHANNEL), ...
    5),4),3);
Constraints = [Constraints,...
    (var_Throughput_matrix(EXCLUDE_IDDENTICALPAIR)<=var_Capacity_Matrix(EXCLUDE_IDDENTICALPAIR)):['Throughput definition']];
Constraints = [Constraints,... % Bug Fixed (this expression is better).
    (var_Throughput.*normalizedDemand(EXCLUDE_IDDENTICALPAIR)<=var_Throughput_matrix(EXCLUDE_IDDENTICALPAIR)):'Total throughput'];



% Constraints (2) one link no wavelength sharing;
logical_sum_Matrix_ofK_atCh_onl = repmat(EXCLUDE_IDDENTICALPAIR,1,1,NUM_ROUTE,NUM_CHANNEL,NUM_EDGE) ...
    .* permute(repmat(bin_sdk_atl,1,1,1,1,NUM_CHANNEL),[1,2,3,5,4]);
var_SingleLink_SingSlot = permute(sum(sum(sum( ...
    repmat(var_bin_sdk_atCh(1:NUM_NODE,1:NUM_NODE,1:NUM_ROUTE,1:NUM_CHANNEL),1,1,1,1,NUM_EDGE) ...
    .*logical_sum_Matrix_ofK_atCh_onl(1:NUM_NODE,1:NUM_NODE,1:NUM_ROUTE,1:NUM_CHANNEL,1:NUM_EDGE),...
    1),... 
    2),... 
    3),... 
    [5,4,1,2,3]);
Constraints = [Constraints,...
    var_SingleLink_SingSlot <=ones(NUM_EDGE,NUM_SLOT)];


% % ==============================
% % Temporaily for RWBA (w1=w2=w3=w4=w5, w6, w7, w8) #demo
% % ==============================
% Constraints = [Constraints,...
%     var_delta_sdk_atCh(1:nNodes,1:nNodes,1:NUM_ROUTES, 1) == var_delta_sdk_atCh(1:nNodes,1:nNodes,1:NUM_ROUTES, 2)];
% Constraints = [Constraints,...
%     var_delta_sdk_atCh(1:nNodes,1:nNodes,1:NUM_ROUTES, 1) == var_delta_sdk_atCh(1:nNodes,1:nNodes,1:NUM_ROUTES, 3)];
% Constraints = [Constraints,...
%     var_delta_sdk_atCh(1:nNodes,1:nNodes,1:NUM_ROUTES, 1) == var_delta_sdk_atCh(1:nNodes,1:nNodes,1:NUM_ROUTES, 4)];
% Constraints = [Constraints,...
%     var_delta_sdk_atCh(1:nNodes,1:nNodes,1:NUM_ROUTES, 1) == var_delta_sdk_atCh(1:nNodes,1:nNodes,1:NUM_ROUTES, 5)];
% 
% % ==============================
% % Temporaily for RWA; (w1=w2=w3=w4, w5=w6=w7, w8) #demo
% % ==============================
% Constraints = [Constraints,...
%     var_delta_sdk_atCh(1:nNodes,1:nNodes,1:NUM_ROUTES, 1) == var_delta_sdk_atCh(1:nNodes,1:nNodes,1:NUM_ROUTES, 2)];
% Constraints = [Constraints,...
%     var_delta_sdk_atCh(1:nNodes,1:nNodes,1:NUM_ROUTES, 1) == var_delta_sdk_atCh(1:nNodes,1:nNodes,1:NUM_ROUTES, 3)];
% Constraints = [Constraints,...
%     var_delta_sdk_atCh(1:nNodes,1:nNodes,1:NUM_ROUTES, 1) == var_delta_sdk_atCh(1:nNodes,1:nNodes,1:NUM_ROUTES, 4)];
% 
% Constraints = [Constraints,...
%     var_delta_sdk_atCh(1:nNodes,1:nNodes,1:NUM_ROUTES, 5) == var_delta_sdk_atCh(1:nNodes,1:nNodes,1:NUM_ROUTES, 6)];
% Constraints = [Constraints,...
%     var_delta_sdk_atCh(1:nNodes,1:nNodes,1:NUM_ROUTES, 5) == var_delta_sdk_atCh(1:nNodes,1:nNodes,1:NUM_ROUTES, 7)];


%% ILP-step3: set objective
Objective = var_Throughput;


%% ILP-step4: solve problem

options = sdpsettings('solver', 'gurobi'...
    , 'verbose',                2 ...
    , 'cachesolvers',           1 ...
    , 'gurobi.FeasibilityTol',  MainOptions.algorithmOption.ILP_FeasibilityTol...
    , 'gurobi.OptimalityTol',   MainOptions.algorithmOption.ILP_OptimalityTol...
    , 'gurobi.MIPGap',          MainOptions.algorithmOption.ILP_MIPGap...
    );
options.gurobi.TimeLimit = MainOptions.algorithmOption.ILP_TimeLimit;

diagnostics = optimize(Constraints,-Objective,options);

if      diagnostics.problem == 0
    disp('Solver thinks it is feasible')
elseif  diagnostics.problem == 1
    disp('Solver thinks it is infeasible')
elseif  diagnostics.problem == -3
    disp('Solver not found, so of course x is not optimized')
else
    disp('Something else happened')
end

t_ILP = toc(eventILP);

%%
% *Passing variables into workspace*


delta_sdk_atCh           = round(value(var_bin_sdk_atCh)); % avoid float value returned by Gurobi;
delta_sdk_atCh           = removeNaN(delta_sdk_atCh);

networkThroughput        = value(var_Throughput);
assert(networkThroughput>=1e-4 ...
    , 'No throughput. Something might be wrong, please check the file or the matrix;');

isEdgeUseSlot            = round(value(var_SingleLink_SingSlot));

yalmip('clear');

%%
% *Computation*
% 

NewNetState                    =  Netstate;

A                               = repmat(EXCLUDE_IDDENTICALPAIR, ...
                                          [1,1,NUM_ROUTE,NUM_CHANNEL] ...
                                         );
NUM_LIGHTPAHTS                  = sum(delta_sdk_atCh(A));

capacityMatrix                  = sum(sum(...
    capacityMatrix_kthRoute_atCh.* delta_sdk_atCh...
    , 4)...
    , 3);
NewNetState.totalCapacityMatrix = capacityMatrix;

NewNetState.isEdgeUseSlot       = isEdgeUseSlot;

% ==============================
% Obtain infos of lightpaths.
% ==============================

a = find(permute(delta_sdk_atCh,[4,3,2,1])==1);
[vec_Ch_ofp,vec_kidx_ofp,vec_dest_ofp,vec_src_node_ofp] = ind2sub([NUM_CHANNEL, NUM_ROUTE,NUM_NODE,NUM_NODE],a);


LightPathSet         = LightPath(NUM_LIGHTPAHTS, NUM_EDGE);
LightPathSet.nSize   = NUM_LIGHTPAHTS;

% Assign basic parameters (s,d,k,w)
for p = 1 : NUM_LIGHTPAHTS
    LightPathSet.no(p)     = p;
    
    % Assign connectionNo
    [cTargetNo] = findNodePairNo(Commodity, [vec_src_node_ofp(p), vec_dest_ofp(p)]);
    assert(~isempty(cTargetNo)...
        , 'not defined commodity'...
        );
    LightPathSet.nodePairNo(p)    = cTargetNo;
    
    LightPathSet.sourceNo(p)        = vec_src_node_ofp(p);
    LightPathSet.destinationNo(p)   = vec_dest_ofp(p);
    LightPathSet.routeNo(p)         = vec_kidx_ofp(p);
    LightPathSet.wavelengthNo(p)    = vec_Ch_ofp(p);
end

% Assign other parameters
for p =1:NUM_LIGHTPAHTS
    LightPathSet.isPathUseEdges(p,1:NUM_EDGE) = ...
        Netstate.isPathOnsdkUseLink(vec_src_node_ofp(p),vec_dest_ofp(p),vec_kidx_ofp(p),1:NUM_EDGE);
end
for p =1:NUM_LIGHTPAHTS
    LightPathSet.hops(p) = 1 + ...
        sum(Netstate.isPathOnsdkUseLink(vec_src_node_ofp(p),vec_dest_ofp(p),vec_kidx_ofp(p),1:NUM_EDGE));
end
for p =1:NUM_LIGHTPAHTS
    LightPathSet.strPath{p}   = printArray(Netstate.candidatePathOfsdk{vec_src_node_ofp(p),vec_dest_ofp(p),vec_kidx_ofp(p)},'-');
end
for p =1:NUM_LIGHTPAHTS
    LightPathSet.cost(p)      = Netstate.lengthOfPathOfsdk(vec_src_node_ofp(p),vec_dest_ofp(p),vec_kidx_ofp(p));
end
for p =1:NUM_LIGHTPAHTS
    LightPathSet.opticalBandNo(p)   = Netstate.opticalBandNoOfSlot(vec_Ch_ofp(p));
end
for p =1:NUM_LIGHTPAHTS
    LightPathSet.transmissionModeNo(p) = targetMod_kthRoute_atCh(vec_src_node_ofp(p), ...
        vec_dest_ofp(p), ...
        vec_kidx_ofp(p), ...
        vec_Ch_ofp(p));
end
for p =1:NUM_LIGHTPAHTS
    LightPathSet.transceiverNo(p) = 1;
end
for p =1:NUM_LIGHTPAHTS
    LightPathSet.capacity(p)        = capacityMatrix_kthRoute_atCh(vec_src_node_ofp(p), ...
        vec_dest_ofp(p), ...
        vec_kidx_ofp(p), ...
        vec_Ch_ofp(p));
end

end


function new_obj = removeNaN(obj)
    idx          = isnan(obj);
    new_obj      = obj;
    new_obj(idx) = 0;
end

function [NetworkThroughput, NewNetState,LightPathSet] = ...
    SequentialLoadingHeu(...
    Networks...
    , NetState ...
    , ReferenceCapacity...
    , Commodity...
    , CandidateOpticalBand ...
    , CandidateTransponder...
    , CandidateModFormat...
    , options...
    )
%% 
%       Sequential loading heuristic
% 
%     1: Select Demand
%     2: Assess current network usage
%     3: if current lightpaths have sufficient capacity then
%     4:      Skip current demand and go to 1
%     5: else 
%     6:      Search for a viable lightpath(FF-kSP, kSP-FF)
%     7:      if current lightpaths have sufficient capacity then 
%     8:           Skip current demand and go to 1
%     9:      else 
%     10:           Demand blocked and stop
%     11:     end
%     12: end
% 
% 
%       **LINE 8**
%  FIXED DEMAND SIZE EQUALS THE MINIMUM POSTIVIE TRANSSSMIION CAPACITY IN 
%  ORDER TO ENSURES ONLY A LIGHTPAHT IS REQUIRED TO ACCOMMODATE DEMAND
%  OTHERWISE, LINE 8 WOULD BE WRONG
% 
% 
%       **LINE 6**
% Algorithm indexing strategy (see below)
% :: for FF-kSP
% (ch,k) : (ch-1) * NUMBER_OF_ROUTES  + k;
%     For example,
%     +REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH+REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH-+REPLACE_WITH_DASH_DASH+REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH+REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH+
%     |                      |     NUMBER_OF_ROUTES=7    |  |                      |     NUMBER_OF_ROUTES=7     |
%     +REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH+REPLACE_WITH_DASH_DASH-+REPLACE_WITH_DASH_DASH-+REPLACE_WITH_DASH_DASH-+REPLACE_WITH_DASH_DASH-+REPLACE_WITH_DASH_DASH-+REPLACE_WITH_DASH_DASH-+REPLACE_WITH_DASH_DASH-+REPLACE_WITH_DASH_DASH+REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH+REPLACE_WITH_DASH_DASH-+REPLACE_WITH_DASH_DASH-+REPLACE_WITH_DASH_DASH-+REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH+REPLACE_WITH_DASH_DASH-+REPLACE_WITH_DASH_DASH-+REPLACE_WITH_DASH_DASH-+
%     |                      | 1 | 1 | 1 | 1 | 1 | 1 | 1 |  |                      | 0 | 1 | 2 | 3  | 4 | 5 | 6 |
%     |                      +REPLACE_WITH_DASH_DASH-+REPLACE_WITH_DASH_DASH-+REPLACE_WITH_DASH_DASH-+REPLACE_WITH_DASH_DASH-+REPLACE_WITH_DASH_DASH-+REPLACE_WITH_DASH_DASH-+REPLACE_WITH_DASH_DASH-+REPLACE_WITH_DASH_DASH+                      +REPLACE_WITH_DASH_DASH-+REPLACE_WITH_DASH_DASH-+REPLACE_WITH_DASH_DASH-+REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH+REPLACE_WITH_DASH_DASH-+REPLACE_WITH_DASH_DASH-+REPLACE_WITH_DASH_DASH-+
%     |                      | 1 | 1 | 1 | 1 | 0 | 0 | 0 |  |                      | 7 | 8 | 9 | 10 | - | - | - |
%     |                      +REPLACE_WITH_DASH_DASH-+REPLACE_WITH_DASH_DASH-+REPLACE_WITH_DASH_DASH-+REPLACE_WITH_DASH_DASH-+REPLACE_WITH_DASH_DASH-+REPLACE_WITH_DASH_DASH-+REPLACE_WITH_DASH_DASH-+REPLACE_WITH_DASH_DASH+                      +REPLACE_WITH_DASH_DASH-+REPLACE_WITH_DASH_DASH-+REPLACE_WITH_DASH_DASH-+REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH+REPLACE_WITH_DASH_DASH-+REPLACE_WITH_DASH_DASH-+REPLACE_WITH_DASH_DASH-+
%     | NUMBER_OF_CHANNELS=5 | 0 | 0 | 0 | 0 | 0 | 0 | 0 |  | NUMBER_OF_CHANNELS=5 | - | - | - | -  | - | - | - |
%     |                      +REPLACE_WITH_DASH_DASH-+REPLACE_WITH_DASH_DASH-+REPLACE_WITH_DASH_DASH-+REPLACE_WITH_DASH_DASH-+REPLACE_WITH_DASH_DASH-+REPLACE_WITH_DASH_DASH-+REPLACE_WITH_DASH_DASH-+REPLACE_WITH_DASH_DASH+                      +REPLACE_WITH_DASH_DASH-+REPLACE_WITH_DASH_DASH-+REPLACE_WITH_DASH_DASH-+REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH+REPLACE_WITH_DASH_DASH-+REPLACE_WITH_DASH_DASH-+REPLACE_WITH_DASH_DASH-+
%     |                      | 0 | 0 | 0 | 0 | 0 | 0 | 0 |  |                      | - | - | - | -  | - | - | - |
%     |                      +REPLACE_WITH_DASH_DASH-+REPLACE_WITH_DASH_DASH-+REPLACE_WITH_DASH_DASH-+REPLACE_WITH_DASH_DASH-+REPLACE_WITH_DASH_DASH-+REPLACE_WITH_DASH_DASH-+REPLACE_WITH_DASH_DASH-+REPLACE_WITH_DASH_DASH+                      +REPLACE_WITH_DASH_DASH-+REPLACE_WITH_DASH_DASH-+REPLACE_WITH_DASH_DASH-+REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH+REPLACE_WITH_DASH_DASH-+REPLACE_WITH_DASH_DASH-+REPLACE_WITH_DASH_DASH-+
%     |                      | 0 | 0 | 0 | 0 | 0 | 0 | 0 |  |                      | - | - | - | -  | - | - | - |
%     +REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH+REPLACE_WITH_DASH_DASH-+REPLACE_WITH_DASH_DASH-+REPLACE_WITH_DASH_DASH-+REPLACE_WITH_DASH_DASH-+REPLACE_WITH_DASH_DASH-+REPLACE_WITH_DASH_DASH-+REPLACE_WITH_DASH_DASH-+REPLACE_WITH_DASH_DASH+REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH+REPLACE_WITH_DASH_DASH-+REPLACE_WITH_DASH_DASH-+REPLACE_WITH_DASH_DASH-+REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH+REPLACE_WITH_DASH_DASH-+REPLACE_WITH_DASH_DASH-+REPLACE_WITH_DASH_DASH-+
% :: for kSP-FF
% (ch,k) : (k-1) * NUMBER_OF_CHANNELS + ch;
%     For example,
%     +REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH+REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH-+REPLACE_WITH_DASH_DASH+REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH+REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH-+
%     |                      |     NUMBER_OF_ROUTES=7    |  |                      |     NUMBER_OF_ROUTES=7    |
%     +REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH+REPLACE_WITH_DASH_DASH-+REPLACE_WITH_DASH_DASH-+REPLACE_WITH_DASH_DASH-+REPLACE_WITH_DASH_DASH-+REPLACE_WITH_DASH_DASH-+REPLACE_WITH_DASH_DASH-+REPLACE_WITH_DASH_DASH-+REPLACE_WITH_DASH_DASH+REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH+REPLACE_WITH_DASH_DASH-+REPLACE_WITH_DASH_DASH-+REPLACE_WITH_DASH_DASH-+REPLACE_WITH_DASH_DASH-+REPLACE_WITH_DASH_DASH-+REPLACE_WITH_DASH_DASH-+REPLACE_WITH_DASH_DASH-+
%     |                      | 1 | 1 | 0 | 0 | 0 | 0 | 0 |  |                      | 0 | 5 | - | - | - | - | - |
%     |                      +REPLACE_WITH_DASH_DASH-+REPLACE_WITH_DASH_DASH-+REPLACE_WITH_DASH_DASH-+REPLACE_WITH_DASH_DASH-+REPLACE_WITH_DASH_DASH-+REPLACE_WITH_DASH_DASH-+REPLACE_WITH_DASH_DASH-+REPLACE_WITH_DASH_DASH+                      +REPLACE_WITH_DASH_DASH-+REPLACE_WITH_DASH_DASH-+REPLACE_WITH_DASH_DASH-+REPLACE_WITH_DASH_DASH-+REPLACE_WITH_DASH_DASH-+REPLACE_WITH_DASH_DASH-+REPLACE_WITH_DASH_DASH-+
%     |                      | 1 | 1 | 0 | 0 | 0 | 0 | 0 |  |                      | 1 | 6 | - | - | - | - | - |
%     |                      +REPLACE_WITH_DASH_DASH-+REPLACE_WITH_DASH_DASH-+REPLACE_WITH_DASH_DASH-+REPLACE_WITH_DASH_DASH-+REPLACE_WITH_DASH_DASH-+REPLACE_WITH_DASH_DASH-+REPLACE_WITH_DASH_DASH-+REPLACE_WITH_DASH_DASH+                      +REPLACE_WITH_DASH_DASH-+REPLACE_WITH_DASH_DASH-+REPLACE_WITH_DASH_DASH-+REPLACE_WITH_DASH_DASH-+REPLACE_WITH_DASH_DASH-+REPLACE_WITH_DASH_DASH-+REPLACE_WITH_DASH_DASH-+
%     | NUMBER_OF_CHANNELS=5 | 1 | 0 | 0 | 0 | 0 | 0 | 0 |  | NUMBER_OF_CHANNELS=5 | 2 | - | - | - | - | - | - |
%     |                      +REPLACE_WITH_DASH_DASH-+REPLACE_WITH_DASH_DASH-+REPLACE_WITH_DASH_DASH-+REPLACE_WITH_DASH_DASH-+REPLACE_WITH_DASH_DASH-+REPLACE_WITH_DASH_DASH-+REPLACE_WITH_DASH_DASH-+REPLACE_WITH_DASH_DASH+                      +REPLACE_WITH_DASH_DASH-+REPLACE_WITH_DASH_DASH-+REPLACE_WITH_DASH_DASH-+REPLACE_WITH_DASH_DASH-+REPLACE_WITH_DASH_DASH-+REPLACE_WITH_DASH_DASH-+REPLACE_WITH_DASH_DASH-+
%     |                      | 1 | 0 | 0 | 0 | 0 | 0 | 0 |  |                      | 3 | - | - | - | - | - | - |
%     |                      +REPLACE_WITH_DASH_DASH-+REPLACE_WITH_DASH_DASH-+REPLACE_WITH_DASH_DASH-+REPLACE_WITH_DASH_DASH-+REPLACE_WITH_DASH_DASH-+REPLACE_WITH_DASH_DASH-+REPLACE_WITH_DASH_DASH-+REPLACE_WITH_DASH_DASH+                      +REPLACE_WITH_DASH_DASH-+REPLACE_WITH_DASH_DASH-+REPLACE_WITH_DASH_DASH-+REPLACE_WITH_DASH_DASH-+REPLACE_WITH_DASH_DASH-+REPLACE_WITH_DASH_DASH-+REPLACE_WITH_DASH_DASH-+
%     |                      | 1 | 0 | 0 | 0 | 0 | 0 | 0 |  |                      | 4 | - | - | - | - | - | - |
%     +REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH+REPLACE_WITH_DASH_DASH-+REPLACE_WITH_DASH_DASH-+REPLACE_WITH_DASH_DASH-+REPLACE_WITH_DASH_DASH-+REPLACE_WITH_DASH_DASH-+REPLACE_WITH_DASH_DASH-+REPLACE_WITH_DASH_DASH-+REPLACE_WITH_DASH_DASH+REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH+REPLACE_WITH_DASH_DASH-+REPLACE_WITH_DASH_DASH-+REPLACE_WITH_DASH_DASH-+REPLACE_WITH_DASH_DASH-+REPLACE_WITH_DASH_DASH-+REPLACE_WITH_DASH_DASH-+REPLACE_WITH_DASH_DASH-+
% ** Similar paper can refer to [CZLX22, ViIS19, IWLS16]
% [CZLX22] Throughput Maximization Leveraging 
%                   Just-Enough SNR Margin and Channel Spacing Optimization
% [ViIS19] Scalable Capacity Estimation for 
%                   Nonlinear Elastic All-Optical Core Networks
% [IWLS16] Using 25 GbE Client Rates to Access 
%                   the Gains of Adaptive Bit-and Code-Rate Networking
% 
%       Selected parameters:
%  <userSeqDemands>                 : archieved unit demands;
%  <SeqDemands>                     : psedo-random sequential demands;
%  <isBlocking_forCommodityNo>      : record blocking for a 
%                                   connection with CommodityNo (s,d);
%     'TerminateStrategy'           : 'fisrt blocking' terminate if any block
%                                   : 'AllBlocking' terminate after all filled
%  <accumBlockingArray_atdemand>    : accumulated blocking after n-th demand
% 
%  <accumTransceiverArray_atdemand> : accum transceivers after n-th demand
%  <minimumCapacity>                : fixed-rate demand size
%  <beta_atlk_sd> and <beta_sdk_atl> are the same except for the dimensions
% 
% 
%   Author: chen.cao{at}sjtu.edu.cn; chen_cao_{at}hotmail.com;
% 

if(isa(ReferenceCapacity, 'double'))
    capacityMatrix_kthRoute_atOpticalBand_atTRXBaud_withM = ReferenceCapacity;
else
    error('Not defined yet');
end

%% SequentialLoadingHeu: initialize
nLimitedTransceivers = options.costLimit;
NUM_NODE             = Networks.nNodes;
NUM_EDGE             = Networks.nEdges;
NUM_ROUTE            = NetState.nRoutes;
NUM_SLOT             = NetState.nSlots;

beta_sdk_atl         = NetState.isPathOnsdkUseLink;
% Another form for representing the beta_sdk_atl;
% (Comment: column indexing is faster than row indexing)
% Date: 24, Jul. 2023
beta_atlk_sd         = permute(beta_sdk_atl,[4,3,1,2]);   

opticalBandNo_ofCh   = NetState.opticalBandNoOfSlot;
nTRxMods             = length(CandidateModFormat);


minimumCapacity     = min(nonzeros(...
    capacityMatrix_kthRoute_atOpticalBand_atTRXBaud_withM));
epsilonCapacity     = minimumCapacity*1e-4;
%% SequentialLoadingHeu-step1: generate demands

% Demand sequences ...
nSamples            = 10000;
% typically, 16e4 demands required for DT14 with TRx at 50 GBd, <<182e4.

nCommodities        = Commodity.nSize;
rng(options.rngSeed);

pseduoRandomSeqFile = sprintf(...
    'data/PseduoRandomDemands-1000/uSeqDemandsC%dN%dR%d.mat'...
    , nCommodities ...
    , nSamples...
    , options.rngSeed...
    );
if exist(pseduoRandomSeqFile)
    load(pseduoRandomSeqFile);
else
    userSeqDemands          = Demand(nSamples*nCommodities);
    for iSample               = 1:nSamples
        % Random sampling without replacement
        idx = datasample([1:nCommodities],nCommodities,'Replace',false); 
        % No replacement for high efficiency;
        
        RandCommodity                   = Commodity.indexing(idx);
        userSeqDemands                  = userSeqDemands.appendn(...
                                                    RandCommodity...
                                                    , nCommodities...
                                                    );
    end
    save(pseduoRandomSeqFile, 'userSeqDemands');
end
SeqDemands          = copy(userSeqDemands); 
% Note: copy class is safer than assign class, since property mix.copyable.
SeqDemands.flowSize = userSeqDemands.flowSize * minimumCapacity; %[Gbps]

delete(userSeqDemands); 
% Note: delete a class

%% SequentialLoadingHeu-step2: loading demands sequentially

% demand status, and lightpath status;
isBlocking_forNodePair          = false(nCommodities,1);
accumBlockingArray_atdemand     = zeros(SeqDemands.nSize,1);
accumTransceiverArray_atdemand  = zeros(SeqDemands.nSize,1);

MAX_LPs_PERNODEPAIR             = round(NUM_SLOT);
LightPathSet                    = LightPath(...
                                    MAX_LPs_PERNODEPAIR*nCommodities ...
                                    , Networks.nEdges...
                                  );
fid_log                         = fopen('Results_heu_log.txt','w+');


% Determing algorithm type
% (Comment: num comparison is more efficient than string comparison);
% Date: 24, Jul. 2023
switch (options.algorithmOption.LoadingStrategy)
    case 'kSP-FF'
        algorithmNo   = 1;
    case 'FF-kSP'
        algorithmNo   = 2;
    otherwise
        error('not define');
end

OldNetState             = NetState;
for iDemand = 1 : SeqDemands.nSize
    nodePairNo          = SeqDemands.nodePairNo(iDemand);
    src                 = SeqDemands.sourceNo(iDemand);
    dst                 = SeqDemands.destinationNo(iDemand);
    demandSizeGbps      = SeqDemands.flowSize(iDemand);
    
    demandBetweenSD     = NetState.totalDemandMatrix(src,dst);
    capacityBetweenSD   = NetState.totalCapacityMatrix(src,dst);
    
    %      Capacity of three options (upgrading mods., increasing transceivers, reconfiguration.)
    capacityByMod       = 0; % Option 1
    
    fprintf(fid_log,"<<Current requirement traffic of logical connection (%d,%d): %g\n",src,dst,demandBetweenSD + demandSizeGbps);
    fprintf(fid_log," On node pair (%d,%d), the provsioned traffic: %g. \n",src,dst,capacityBetweenSD);
    
    % ==============================
    %	Sequential network status.
    % ==============================
    %       - network blocking;
    accumBlockingArray_atdemand(iDemand) = accumBlockingArray_atdemand(max(iDemand-1,1));
    if((isBlocking_forNodePair(nodePairNo)==true)) % Record accumBlocking status if (src,dst) is already blocked.
        accumBlockingArray_atdemand(iDemand) = accumBlockingArray_atdemand(max(iDemand-1,1)) + 1;
    end
    
    %       - no. transceivers.
    accumTransceiverArray_atdemand(iDemand) = accumTransceiverArray_atdemand(max(iDemand-1,1));
    
    isAccommodated      = false; % true if the current demand is accepted;
    isEstablished       = false; % true if a new lightpath is established;

    if((isBlocking_forNodePair(nodePairNo)==true) || ...
            (capacityBetweenSD>=demandBetweenSD+demandSizeGbps) || ...
            (epsilonCapacity>=abs(demandBetweenSD+demandSizeGbps - capacityBetweenSD) ) ) 
        % no requirement for the updating;
        % Comment: epsilonCapacity is used to fix bug when >= loses accuray.
        fprintf(fid_log,"[keep] \n");
        isAccommodated  = true;
        NetState.totalDemandMatrix(src,dst) = NetState.totalDemandMatrix(src,dst) + demandSizeGbps;
        continue;
    else
        fprintf(fid_log,"[Needs network operation]: update mods., create a lightpath, or reconfigure between node pair\n");
        isAccommodated   = false;
    end
    
    if(~isAccommodated && ...
            LightPathSet.nSize<nLimitedTransceivers)
        % Skip if the transceiver count exceeds the maximum number.
        %==============================
        %     Method 3 :  Establish new lightpath; 
        % :: Only one lightpath would be enough, as the demand is the minimum positive
        % ==============================
        fprintf(fid_log,"Method : establish a new lightpath\n");

        iLastSearching = NetState.userParameters(src,dst);
        for iSearching = (iLastSearching+1): NUM_SLOT* NUM_ROUTE
            switch (algorithmNo)
                case 1 % 'kSP-FF'
                    [iChannel,iRoute]   = revertRouteChannel(iSearching,NUM_SLOT, NUM_ROUTE);
                case 2 % 'FF-kSP'
                    [iChannel,iRoute]   = revertChannelRoute(iSearching,NUM_SLOT, NUM_ROUTE);
                otherwise
                    error('not define');
            end
            
            bin_edge = logical(beta_atlk_sd(1:NUM_EDGE,iRoute,src,dst));
            bin_inspectionSlots = NetState.isEdgeUseSlot(bin_edge,iChannel);
            if(any(any(bin_inspectionSlots)))
                continue; % Skip searching if all slots are occupied
            end
            
            tb  = 1;
            [capacityByNewLightPath, targetm] = max( ...
                capacityMatrix_kthRoute_atOpticalBand_atTRXBaud_withM(...
                src,dst,iRoute,opticalBandNo_ofCh(iChannel),tb,1:nTRxMods)...
                );
            if(capacityByNewLightPath>=epsilonCapacity&&capacityBetweenSD ...
                    + capacityByMod + capacityByNewLightPath >= ...
                    demandSizeGbps+demandBetweenSD)
                fprintf(fid_log,"Accepted current lighpath p<%d,%d,%d,%d,%d> (%g + %g + %g >= %g)\n",...
                    src,dst, iRoute, iChannel, targetm, ...
                    capacityBetweenSD, capacityByMod,capacityByNewLightPath,...
                    demandSizeGbps+demandBetweenSD...
                    );
                isEstablished = true;
                break;
            end
        end
        % % REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH
        % Update last searching index only if current index is non-empty.
        % (Comment: empty index occurs when its value exceeds
        %           NUMBER_OF_CHANNELS* NUMBER_OF_ROUTES)
        if isempty(iSearching) == false
            NetState.userParameters(src, dst) = iSearching;
        end
        if isEstablished
            fprintf(fid_log,">>>>Summary of method 3: Okay, lightpath found succcessed\n");
            pid	= LightPathSet.nSize + 1;
            
            LightPathSet.nSize = LightPathSet.nSize  +1;
            LightPathSet.nodePairNo(pid) = nodePairNo;
            LightPathSet.no(pid) = pid;
            LightPathSet.sourceNo(pid) = src;
            LightPathSet.destinationNo(pid) = dst;
            LightPathSet.routeNo(pid) = iRoute;
            LightPathSet.isPathUseEdges(pid,1:NUM_EDGE) = bin_edge(1:NUM_EDGE);
            LightPathSet.transmissionModeNo(pid) = targetm;
            LightPathSet.transceiverNo(pid) = tb;
            LightPathSet.nFrequencySlots(pid) = 1;
            LightPathSet.wavelengthNo(pid) = iChannel;
            LightPathSet.opticalBandNo(pid) = opticalBandNo_ofCh(iChannel);
            LightPathSet.capacity(pid) = ...
                capacityMatrix_kthRoute_atOpticalBand_atTRXBaud_withM(...
                src,dst,iRoute,opticalBandNo_ofCh(iChannel),tb, targetm);
            
            LightPathSet.strPath{pid} = printArray(NetState.candidatePathOfsdk{src, dst, iRoute});
            isAccommodated =true;
        else
            isAccommodated;
        end
        
        
        
    end
    
    fprintf(fid_log,...
        "\n>>>>Summary: update the current (%d,%d) node pair, current:required = %g:%g\n",...
        src,dst,...
        capacityBetweenSD + capacityByMod +  capacityByNewLightPath,...
        demandBetweenSD + demandSizeGbps);
    if(~isAccommodated&&~isEstablished)
        fprintf(fid_log,"It's failed, and we donot update the lightpath.\n");
        isBlocking_forNodePair(nodePairNo) = true;
        accumBlockingArray_atdemand(iDemand) = ...
            accumBlockingArray_atdemand(iDemand-1) + 1;
    end
    
    % ==============================
    %         Update for next traffic demand.
    % ==============================
    if isEstablished
        NetState.isEdgeUseSlot(LightPathSet.isPathUseEdges(pid,1:NUM_EDGE),...
            LightPathSet.wavelengthNo(pid)) = true;
        NetState.totalCapacityMatrix(src,dst) = ...
            NetState.totalCapacityMatrix(src,dst) ...
            + LightPathSet.capacity(pid);
        NetState.totalDemandMatrix(src,dst) = ...
            NetState.totalDemandMatrix(src,dst) + demandSizeGbps;
        OldNetState = NetState;
        accumTransceiverArray_atdemand(iDemand) = ...
            accumTransceiverArray_atdemand(iDemand) + 1; 
    else
        NetState = OldNetState;
    end
    
    % ==============================
    %         Update for next node pair.
    % ==============================
    switch(options.algorithmOption.TerminateStrategy)
        case 'First-blocking'% Case 1: Terminate if <any is blocked> .
            isTerminate = any(isBlocking_forNodePair == 1);
        case 'All-blocking'% Case 2: Terminate if <all are blocked> .
            isTerminate = all(isBlocking_forNodePair == 1);
        otherwise
            error('not specified');
    end
    
    % ==============================
    % Plot Network.
    % ==============================     
    %     pause(0.1);
    %     if(isEstablished)
    %     pause(0.001);
    %     figure(87),
    %     clf;
    %     imagesc(logical(NetState.isEdgeUseSlot));colorbar;
    %     title('Spectrum Usage Graph');
    %     xlabel('Slot');
    %     ylabel('Link');
    %     end
    % ==============================
    %     Print out results.
    % ==============================
    fprintf(fid_log,"\n\nThe current informations of network\n");
%     for iNodePair = 1:Networks.nNodes*(Networks.nNodes-1)
%         fprintf(fid_log,"The number of lighpaths is %d (NodePairID = %d), capacity = %g\n", LightPathSet_OfNodePair(iNodePair).nSize,...
%             iNodePair,...
%             NetState.totalCapacityMatrix(Commodity.source(iNodePair), Commodity.destination(iNodePair)));
%     end
    if(isTerminate)
        fprintf(fid_log,"We force to terminate the program\n");
        break;
    end
    fprintf(fid_log,...
        "The current round number is %d with network throughput: %g \n",...
        iDemand, min(min(NetState.totalDemandMatrix./NetState.normDemandMatrix)));    
end
fclose(fid_log); % close file after the loading is stopped.

if iDemand == SeqDemands.nSize
    fprintf('Terminate after full samplings\n');
elseif isTerminate == 1
    fprintf('Terminate after blocking\n');
else
    ;
end
    
%% SequentialLoadingHeu-step3: return demands and capacity
NewNetState          = OldNetState;
STATUS_ACTIVE_CONNECTIONS= NetState.STATUS_ACTIVE_CONNECTIONS;
NetworkThroughput    = min(NetState.totalCapacityMatrix(STATUS_ACTIVE_CONNECTIONS)...
    ./ NetState.normDemandMatrix(STATUS_ACTIVE_CONNECTIONS));
% Mark: There could be different meanings on the throughput. 
%   We denote network throughput by the working demand

end


function [newBand] = assignSlotPosition(oldBand)
%       update candidate optical band's beginning and ending slots.

[nBands]                = length(oldBand);
vec_nSlot_atOpticalBand = getNumeric(oldBand...
    , 'nFrequencySlots');

vec_slotBegin_atBand   = cumsum([1;vec_nSlot_atOpticalBand(:)]);
vec_slotEnd_atBand     = cumsum([0;vec_nSlot_atOpticalBand(:)]);
assert(all(rem(vec_slotBegin_atBand,1) == 0) ... 
    , 'MATLAB:assignSlotPosition:UnExpectedResults' ...
    , 'Wrong Slots Setting'...
    ); % Check non-integer slots beginning

% Update optical band's start and end slots status
newBand = oldBand;
for iBand = 1:nBands
   newBand(iBand).sbegin = vec_slotBegin_atBand(iBand);
   newBand(iBand).send   = vec_slotEnd_atBand(iBand+1);
end

end

function [isEdgeUseSlot, opticalBandNoOnSlot] = initializeEdgeSlot(...
    isEdgeUseBand ...
    , candidateBand...
    )
% compute initial slot and optical band information for each edge.

[nEdges, nBands] = size(isEdgeUseBand);
vec_nSlot_atBand = getNumeric(candidateBand, 'nFrequencySlots');
nSlots           = sum(vec_nSlot_atBand);

isEdgeUseSlot    = ones(nEdges, nSlots);
for iEdges = 1 : nEdges
    for jBand = 1 : nBands
        thisBand = candidateBand(jBand);
        if(isEdgeUseBand(iEdges, jBand) == 1 ...
                && all(all(...
                isEdgeUseSlot(iEdges,thisBand.sbegin : thisBand.send) == 1 ...
                )...
                )...
                )
            isEdgeUseSlot(iEdges,thisBand.sbegin : thisBand.send) = 0;
        end
    end
end

% Optical band ID;
% id = -1 : for NULL, 
% id =  0 : for channel crossed-by two bands;
% id >= 1 : channel ID
opticalBandNoOnSlot = -1 + zeros(nSlots,1); 
for iiBand = 1 : nBands
    thisBand = candidateBand(iiBand);
    opticalBandNoOnSlot(thisBand.sbegin : thisBand.send) = iiBand;
end

end

function [newObj] = sortClass(oldObj, keyName, direction)
% return class array according to the class's keyname type.

nObj = length(oldObj);
assert(any(strcmp(properties(oldObj(1)), keyName)) ...
    , 'MATLAB:sortClass:UnMatchName' ...
    , 'no such properties!'...
    );

% Check size of input argument
try 
    narginchk(2,3);
catch ME
    error(ME.message);
end

if nargin == 2
    direction = 'ascend';
else
    % deal with other 3 inputs
end

metrics           = zeros(1,nObj);
for iObj = 1 : nObj
    thisObj       = oldObj(iObj);
    metrics(iObj) = thisObj.(keyName);
end %

[~, idx_sort] = sort(metrics,direction);
newObj        = oldObj;

for iiObj = 1 : nObj
    newObj(iiObj) = oldObj(idx_sort(iiObj));
end %

end


function [TotalTransmissionMode, nTotalTransmissionModes] = ...
    initializeTransmissionMode(SimulationSetting)

defaultBaud = SimulationSetting.('default_baud_rate');  
% defaultBaud = 50; % #demo: example capacity for 50 Gbps per step.

namePattern             = '^PM_';
nameList                = findFieldNames(SimulationSetting, namePattern); 
nTotalTransmissionModes = length(nameList);

TotalTransmissionMode     = [];
for iMod = 1 : nTotalTransmissionModes
    keyName        = nameList{iMod};

    valueArray     = SimulationSetting.(keyName);
    ValueStructure = struct(...
        'name',         keyName...
        ,'SNRdB',       valueArray(1) ...
        ,'dataRate',    valueArray(2) ...
        ,'reach',       valueArray(3) ...
        ,'defaultBaud', defaultBaud   ...
        );;
    thisMode        = TransmissionMode(ValueStructure);
    
    TotalTransmissionMode = [TotalTransmissionMode, thisMode];    
end

end

function  [TotalTransceiver,nTotalTransceiver] = ...
    initializeTransceiver(SimulationSetting)
    % find possible names with filed pattern '^Trans\w*[G]'
    % initialize transceivers with the value of this fields.
    
    % find names;
    namePattern         = '^Trans\w*[G]';
    nameList            = findFieldNames(SimulationSetting,namePattern);
    nTotalTransceiver   = length(nameList);
    
    % initialize transceivers
    TotalTransceiver = [];
    for iTransceiver = 1 : nTotalTransceiver
        thisName        = nameList{iTransceiver};
        valueArray      = SimulationSetting.(thisName);
        ValueStructure  = struct('name',    thisName...
            ,'bandwidth',                   valueArray(1)...
            ,'numberOfFrequencySlots',      valueArray(2) ...
            ,'capacity',                    valueArray(3) ...
            ,'penalty',                     valueArray(4) ...
            ,'baud_rate',                   valueArray(5) ...
            );
        Trans_xG         = Transceiver(ValueStructure); 
        TotalTransceiver = [TotalTransceiver, Trans_xG];
    end
end

function [isEdgeUseOpticalBand] = ...
    initializeFiberOpticalBand(Networks ...
    , candidateOpticalBandArray ...
    , bandProfileSetting)

isEdgeUseOpticalBand = ...
    zeros(Networks.nEdges, numel(candidateOpticalBandArray));
for iEdge = 1 : Networks.nEdges
    
    %     find optical band settings, on a link <iEdge>
    [mNode,nNode]   = find(Networks.edgeIndexMatrix==iEdge);
    searchPattern   = sprintf('link_%dto%d$',mNode,nNode);
    nameList        = findFieldNames(bandProfileSetting, searchPattern);
    assert(...
        length(nameList) == 1 ...
        ,'MATLAB:intializeFiberOpticalBand:UnMatchedSize'...
        ,'not proper wide-band settings'...
        );
    
    bandNames       = bandProfileSetting.(nameList{1});
    [OpticalBandArray,nOpticalBand] = getClassByFields(...
        bandNames, 'name', candidateOpticalBandArray);
    
    for jOpticalBand = 1 : nOpticalBand
        for kOpticalBand = 1 : length(candidateOpticalBandArray)
            %  true (1) if name matches candidateOpticalBand,
            %  false(0) otherwise.
            %  Note: We designate the optical band No of the candidate 
            %         optical band.
            if(strcmp(...
                    OpticalBandArray(jOpticalBand).name ...
                    , candidateOpticalBandArray(kOpticalBand).name...
                    ))
                isEdgeUseOpticalBand(iEdge, kOpticalBand) = true;
                break;
            else
                isEdgeUseOpticalBand(iEdge, kOpticalBand) = false;
            end
        end
    end
end

end


function MultiCommodityFlow = initializeCommodityFlows(SimulationSetting)

nCommodiyFlow      = length(SimulationSetting.commodity_src);
MultiCommodityFlow = Demand(nCommodiyFlow);

MultiCommodityFlow.nSize(1) = nCommodiyFlow;

MultiCommodityFlow.no(1 : nCommodiyFlow) = ...
    [1 : length(SimulationSetting.commodity_src)]; 

MultiCommodityFlow.nodePairNo(1:nCommodiyFlow) = ...
    [1 : length(SimulationSetting.commodity_src)];

MultiCommodityFlow.sourceNo(1:nCommodiyFlow) = ...
    SimulationSetting.commodity_src;

MultiCommodityFlow.destinationNo(1:nCommodiyFlow) = ...
    SimulationSetting.commodity_dst;

MultiCommodityFlow.flowSize(1:nCommodiyFlow) = ...
    SimulationSetting.commodity_amount;

assert( ...
       numel(MultiCommodityFlow.sourceNo)     == MultiCommodityFlow.nSize ...
    && numel(MultiCommodityFlow.destinationNo)== MultiCommodityFlow.nSize ...
    && numel(MultiCommodityFlow.flowSize)     == MultiCommodityFlow.nSize...
    , 'MATLAB:intializeCommodityFlows:UnMatchedSize'...
    , 'Wrong commodity flow'...
    );
assert(length(unique(...
    [MultiCommodityFlow.sourceNo, MultiCommodityFlow.destinationNo], 'rows'...
    )) == MultiCommodityFlow.nSize ...
    ,'MATLAB:intializeCommodityFlows:UnExpectedSize'...
    ,'Replicated Commodity'...
    );
end

function [TotalOpticalBand, nTotalOpticalBand, frequencySlots] = ...
    initializeOpticalBand(SimulationSetting)
frequencySlots      = SimulationSetting.frequency_slots;

% Import UWB name;
searchPattern       ='[a-zA-Z]Band$';
nameOfOpticalBands  = findFieldNames(SimulationSetting,searchPattern);
nTotalOpticalBand   = length(nameOfOpticalBands);

TotalOpticalBand            = [];
for i = 1:nTotalOpticalBand
    keyName         = nameOfOpticalBands{i};
    valueArray      = SimulationSetting.(keyName);
    ValueStructure  = struct('name',keyName ...
        ,'spectrum_resource',       valueArray(1)...
        ,'max_transceivers',        valueArray(2) ...
        ,'SNRpenaltydB',            valueArray(3) ...
        ,'center_frequency',        valueArray(4) ...
        ,'frequency_slots',         frequencySlots...
        );
    
    TotalOpticalBand = [TotalOpticalBand, ...
        OpticalBand(ValueStructure)];
end

end

function userNetworks = ...
    initializeNetworks(networkTag, distanceMatrix, longitudeArray, latitudeArray)
% user-defined network initialization.
%   default_networks[struct]:
%       'NoNodes'            : [1] number of nodes, size of node set V;
%       'NoEdges'            : [1] number of edges, size of edge set E;
%       'adjacentMatrix'     : [matrix |V|*|V|] adjacency matrix of a network,  (u,v) : 1 if u is connected with v, 0 otherwise.
%       'edgeIndexMatrix'    : [matrix |V|*|V|] adjacency matrix with ID index, (u,v) : LinkID for the l-th links in a network.
%                         e.g., for a 4-node ring;  
%                               AdjacentMatrix is 
%                                 [0 1 0 1;
%                                 1 0 1 0;
%                                 0 1 0 1;
%                                 1 0 1 0];
%                               LinkIndexMatrix is
%                                 [0 3 0 7;
%                                 1 0 5 0;
%                                 0 4 0 8;
%                                 2 0 6 0];
%       'distanceMatrix'     : [matrix |V|*|V|] Physical-distance for an edge (u, v), 0 if (u,v) are not connected.
%       'vec_length_atl'     : length of a link;
%       'longtitudeArray'    : [matrix |V|*1]   east-west position of a point in the earth
%       'latitudeArray'      : [matrix |V|*1]   south-north position of a point in the earth
%       'Diameter'           : [1] longest shortest path;
% 'distanceShortestPathMatrix': [matrix |V|*|V|] length of the shortest path between (s,d);
% ==============================
%           Topology
% ==============================
default_networks = struct(...
    'tag', [],...
    'nNodes', [], ...
    'nEdges', [], ...
    'adjacentMatrix', [], ...
    'edgeIndexMatrix', [], ... 
    'distanceMatrix', [], ...
    'linkLengthArray', [], ...
    'longtitudeArray', [], ...
    'latitudeArray', [], ...
    'diameter', [], ...
    'distanceShortestPathMat', []...
    );
%% 
userNetworks     = default_networks;
userNetworks.tag = networkTag;

NUM_NODE         = size(distanceMatrix,1);
NUM_EDGE         = sum(sum(logical(distanceMatrix)));
adjacentMatrix   = logical(distanceMatrix);

% Check for no. nodes
% assert((nNodes==numel(longitudeArray) || nNodes*~isempty(longitudeArray)==numel(longitudeArray) ) ...
%     && (nNodes==numel(latitudeArray) || nNodes*~isempty(latitudeArray)==numel(latitudeArray) ) ...
%     , 'Wrong location coordinate');
assert(...
      (NUM_NODE == numel(longitudeArray))...
    &&(NUM_NODE == numel(latitudeArray)) ...
    , 'MATLAB:initializeNetworks:UnMatchedSize'...
    , 'Wrong location coordinate'...
    );

% Check bi-connected graph : avoid sole island
assert(...
    all(computeNodeDegree(adjacentMatrix) ~= 0)...
    , 'MATLAB:initializeNetworks:InvalidInput'...
    , 'Unsatisifed Matrix, sole node island'...
    );

% ==============================
% Basic parameters initializing
% ==============================
userNetworks.adjacentMatrix = logical(distanceMatrix);
userNetworks.distanceMatrix = distanceMatrix;
userNetworks.linkLengthArray= distanceMatrix(logical(distanceMatrix)); 
% Note: EdgeWeightSet, first-row indexing as matlab default
userNetworks.nNodes         = NUM_NODE;
userNetworks.nEdges         = NUM_EDGE;
userNetworks.latitudeArray  = latitudeArray;
userNetworks.longtitudeArray= longitudeArray;

% ==============================
% Advanced initialzation initializing (one block for one parameter)
% ==============================
edgeIndexMatrix           	= zeros(NUM_NODE,NUM_NODE);
indexOfEdge = 0;
for d = 1:NUM_NODE
    for s = 1:NUM_NODE
        if(adjacentMatrix(s,d)==true)
            indexOfEdge         = indexOfEdge +1;
            edgeIndexMatrix(s,d) = indexOfEdge;
        else
            edgeIndexMatrix(s,d) = 0;
        end
    end
end
userNetworks.edgeIndexMatrix = edgeIndexMatrix;

costMatrix = fixCostMatrix(distanceMatrix); % MATLAB version.

distanceShortestPathMatrix = zeros(NUM_NODE,NUM_NODE);
for s = 1 : NUM_NODE
    for d = 1 : NUM_NODE
        if s == d
            continue;
        end
        [~,pathLength] = kShortestPath(costMatrix,s,d,1);
        if(isempty(pathLength))
            distanceShortestPathMatrix(s,d) = NaN;
            continue;
        end
        distanceShortestPathMatrix(s,d) = pathLength;
    end
end
userNetworks.diameter     = max(max(distanceShortestPathMatrix));

userNetworks.distanceShortestPathMat = distanceShortestPathMatrix;

fprintf('Max Shortestpath= %g * 100km\n', max(max(distanceShortestPathMatrix)));
end

function UserNetstate = ...
    initializeNetworkState(Networks, nRoutes, nSlots, Commodity)
% user-defined network state function.
%   netstate:
%       'nSlots'         : [1] number_of_slots, number of wavelengths, W, etc.;
%       'nRoutes'        : [1] number of candidate routes, K;
%  'candidatePathOfsdk'  : [cell matrix |V|*|V|*K] all candidate paths;
%  'lengthOfPathOfsdk'   : [matrix |V|*|V|*K] length of these candidate paths;
% 
%  'isPathOnsdkUseLink'  : [matrix |V|*|V|*K*|E|] boolean whether p(s,d,k) 
%                          uses the lth link. In case path_(s,d,k) does not 
%                          exist, we assume p(s,d,k) occupying all edges 
%                          with full resource utilization.
%   'normDemandMatrix'   : [matrix |V|*|V|] normalized traffic demand
%                          profile in a network, 0\leq D(s,d)\leq 1. 
%       'LinkSlotBlock'  : [matrix |E|*W] logical matrix indicating 
%                           occupied status of l-th edge and w-th wavelength
%   'totalCapacityMatrix': [matrix |V|*|V|] Ts,d, transmission capacity matrix
%   'totalDemandMatrix'  : [matrix |V|*|V|] Ts,d, demand capacity matrix
%                          between (s,d) ; 
% 
%  'userParameters'          : no exact meanings, customed by users.
%'STATUS_ACTIVE_CONNECTIONS' : [matrix |V|*|V|] acitve connections by 
%                              <normalizedDemand>
%'STATUS_TRUE_CONNECTIONS'   : [matrix |V|*|V|] true connections, 
%                              Mat(s,d) eq 1, for all s\neq d;
default_netstate = struct('nSlots', [], ...
    'nRoutes', [], ...
    'candidatePathOfsdk', [],... % path means (s,d,k);
    'lengthOfPathOfsdk', [], ... % cost of path (s,d,k);
    'isPathOnsdkUseLink', [], ...  % path means (s,d,k);
    'normDemandMatrix', [], ...
    'isEdgeUseSlot', [], ... 
    'totalCapacityMatrix',[],...
    'totalDemandMatrix', [],...
    'STATUS_ACTIVE_CONNECTIONS', [], ... activated by multi-commodity flows.
    'STATUS_TRUE_CONNECTIONS', [], ... all true if s\neq d.
    'userParameters',[], ...
    'opticalBandNoOfSlot', [] ...
    );
UserNetstate            = default_netstate;

% network basic parameter
UserNetstate.nSlots     = nSlots;
UserNetstate.nRoutes    = nRoutes;

nNodes                  =  Networks.nNodes;
nEdges                  =  Networks.nEdges;

% candidate routes' status initlization
candidatePathOfsdk          = cell(nNodes,nNodes,nRoutes);
lengthOfCandidatePathOfsdk  = ones(nNodes,nNodes,nRoutes)*1e10;
costMatrix                  = fixCostMatrix(Networks.distanceMatrix);
for s =1:nNodes
    for d =1:nNodes
        if(s==d)
            continue;
        end
        [Path,Cost] = kShortestPath(costMatrix,s,d, nRoutes);
        
        lengthOfCandidatePathOfsdk(s,d,1:length(Cost))  = Cost;
        candidatePathOfsdk(s,d,1:length(Path))          = Path;
    end
end
UserNetstate.candidatePathOfsdk  = candidatePathOfsdk;
UserNetstate.lengthOfPathOfsdk   = lengthOfCandidatePathOfsdk;

UserNetstate.isPathOnsdkUseLink = zeros(nNodes,nNodes,nRoutes, nEdges, 'logical');
for s =1:nNodes
    for d =1:nNodes
        if(s==d)
            continue;
        end
        for k =1:nRoutes
            if isempty(UserNetstate.candidatePathOfsdk{s,d,k})
                UserNetstate.isPathOnsdkUseLink(s,d,k,1:nEdges) = true;
            else
                isLinkArray = convertVertexListToEdgeStatus(...
                    UserNetstate.candidatePathOfsdk{s,d,k}...
                    , Networks.edgeIndexMatrix...
                    );
                UserNetstate.isPathOnsdkUseLink(s,d,k,logical(isLinkArray))...
                    = true;
            end
        end
    end
end


nCommodity            = Commodity.nSize;

vec_srcNo_ofCommodity = Commodity.sourceNo;
vec_dstNo_ofCommodity = Commodity.destinationNo;
vec_flows_ofCommodity = (Commodity.flowSize)./sum(Commodity.flowSize);

demandRatioMatrix     = zeros(nNodes,nNodes);
for iCommodity = 1:nCommodity
    demandRatioMatrix(vec_srcNo_ofCommodity(iCommodity), ...
        vec_dstNo_ofCommodity(iCommodity)) ...
        = vec_flows_ofCommodity(iCommodity);
end
UserNetstate.normDemandMatrix = demandRatioMatrix;

UserNetstate.STATUS_TRUE_CONNECTIONS ...
    = logical(ones(nNodes,nNodes)-eye(nNodes,nNodes));

isActiveOnConnetions = false(nNodes,nNodes);
for iCommodity = 1:nCommodity
    isActiveOnConnetions(vec_srcNo_ofCommodity(iCommodity),...
        vec_dstNo_ofCommodity(iCommodity)) = true;
end
UserNetstate.STATUS_ACTIVE_CONNECTIONS = isActiveOnConnetions;

UserNetstate.totalCapacityMatrix    = zeros(nNodes,nNodes); % [Gbps]

UserNetstate.totalDemandMatrix      = zeros(nNodes,nNodes); % [Gbps]

% Edge slot status
UserNetstate.isEdgeUseSlot          = zeros(nEdges, nSlots);

end

function minRequiredSNR_Matrix_kthRoute_atOpticalBand_atTRXBaud_withM = ...
    initializeRequiredSNR(...
    minReq_Pathsdk_OpticalBand_TRx_TRxMod...
    , CandidateModFormat...
    )
[nNodes,~,nRoute,nOpticalbands,nTRxs,nTRxMods] ...
    = size(minReq_Pathsdk_OpticalBand_TRx_TRxMod);
minRequiredSNR_Matrix_kthRoute_atOpticalBand_atTRXBaud_withM ...
    = zeros(nNodes,nNodes,nRoute,nOpticalbands,nTRxs,nTRxMods);
for s = 1 : nNodes
    for d = 1 : nNodes
        if s == d
            continue;
        end
        for k = 1 : nRoute
            for ob = 1 : nOpticalbands
                for tb = 1 : nTRxs
                    for m = 1 : nTRxMods
                        % initialize the SNR;
                        minRequiredSNR_Matrix_kthRoute_atOpticalBand_atTRXBaud_withM(s,d,k,ob,tb, m) ...
                            = CandidateModFormat(m).SNR * minReq_Pathsdk_OpticalBand_TRx_TRxMod(s,d,k,ob,tb, m); 
                    end
                end
            end
        end
    end
end
end

function CapacityMatrix_kthRoute_atOpticalBand_atTRXBaud_withM ...
    = assignCapacityForAllCandidates(...
    worstSNR_Pathsdk_atOpticalBand_atBaud_withM ...
    , minRequiredSNR_Pathsdk_atOpticalBand_atTRXBaud_withM...
    , CandidateTransponder...
    , CandidateModFormat...
    )
% Comment: uses the array class object instead of cell class object. 30th, Jun. 2023.
[nNodes, ~, nRoutes, nOpticalBands, nTRxs, nTRxMods] =...
    size(minRequiredSNR_Pathsdk_atOpticalBand_atTRXBaud_withM);

CapacityMatrix_kthRoute_atOpticalBand_atTRXBaud_withM =...
    zeros(nNodes, nNodes, nRoutes, nOpticalBands, nTRxs, nTRxMods);
for s = 1 : nNodes
    for d = 1 : nNodes
        if s == d
            continue;
        end
        for k = 1 : nRoutes
            for ob = 1 : nOpticalBands
                for tb = 1 : nTRxs
                    for m = 1 : nTRxMods
                        if(worstSNR_Pathsdk_atOpticalBand_atBaud_withM(s,d,k,ob,tb,m) ...
                                >= minRequiredSNR_Pathsdk_atOpticalBand_atTRXBaud_withM(s,d,k,ob,tb,m))
                            % Capacity = Baud-Rate * SpectralEfficiency.
                            CapacityMatrix_kthRoute_atOpticalBand_atTRXBaud_withM(s,d,k,ob,tb,m) = ...
                                CandidateTransponder(tb).GBaud * CandidateModFormat(m).spectralEfficiency;
                        end
                    end
                end
            end
        end
    end
end
end



function showEdgeSpectrumGraph(...
    isEdgeUseSlot...
    , EdgeUseSlotWithOpticalBandNo...
    , CandidateOpticalBand)
% Description: 
%  This function is used to show network spectrum usage 
%   colored by optical band ID 
%   
% 
% Created by Cao. CHEN
%  Date: 7th, Mar. 2023
% Comment: cell classREPLACE_WITH_DASH_DASH>array class object;


% Basic Parameters
NUMBER_OF_BANDS = length(CandidateOpticalBand);
NUMBER_OF_SLOTS = size(isEdgeUseSlot,2);

BandNameStr = getChar(CandidateOpticalBand, 'name');

cmap_matrix = [...
    1.0, 1.0, 1.0;  % for occupied slot;
    0.17, 0.17, 0.17; % for 1st band;
    0.33, 0.33, 0.33; % for 2nd band;
    0.5, 0.5, 0.5;    % for 3rd band;
    0.67, 0.67, 0.67; % for 4th band;
    0.83, 0.83, 0.83]; % for 5th band;

% ==============================
% Conversion.
% ==============================
ColoredLinkSlotBlock = isEdgeUseSlot.*EdgeUseSlotWithOpticalBandNo;

% ==============================
% Show plots.
% ==============================

figure(202), clf;
image(ColoredLinkSlotBlock+1), % avoiding 0 and 1 take the same index.
colormap(gcf, cmap_matrix);
xlabel('Channel Number')
ylabel('Link ID');
xlim([0.5, NUMBER_OF_SLOTS+0.5]);


% Colorbar setting.
colorbar('peer',gca,'northoutside',...
    'Ticks', 0.5 + [1:(NUMBER_OF_BANDS+2)],...
    'Limits',[1 (NUMBER_OF_BANDS+2)], ...
    'TickLabels',['Idle',strsplit(BandNameStr,{',', ' '})]);


% ==============================
% Export figure as .png file.
% ==============================
figure(201), clf;
image(ColoredLinkSlotBlock+1), % avoiding 0 and 1 take the same index.
colormap(gcf, cmap_matrix);
axis off;
xlim([0.5, NUMBER_OF_SLOTS+0.5]);
export_fig spectrum_usage_graph.png % famous open-source export function export_fig.m is required.
end

function LightPathSet = addWavelength(...
    LPonConfig, ...
    Repeated_Configurations, ...
    configNo_ofCh, ...
    ColorlessLightPath)
% Description: 
% 
%   This function generates lightpaths by adding wavelength 
%               to each **colored** configuration.
% 
% REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH
% Created by cchen, 15th, Jun. 2022
% REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH
% Add output kidx.
% Modified by cchen, 22nd, Mar. 2023;


% ==============================
% Obtain parameters to be used;
% ==============================
sefficiency_ofp         = ColorlessLightPath.capacity;
vec_uv_onp              = ColorlessLightPath.isPathUseEdges';
cost_p                  = ColorlessLightPath.cost;
vec_hops_onp            = ColorlessLightPath.hops;
vec_src_node_ofp        = ColorlessLightPath.sourceNo;
vec_dst_node_ofp        = ColorlessLightPath.destinationNo;
vec_kidx_ofp            = ColorlessLightPath.routeNo;
vec_nodePairNo_ofp      = ColorlessLightPath.nodePairNo;
vec_Mod_ofp             = ColorlessLightPath.transmissionModeNo;
vec_strPath_ofp         = ColorlessLightPath.strPath;
vec_ColoredConfigID_ofCh= configNo_ofCh;
MAXIMUM_LPs_CONFIGURE   = size(LPonConfig,1);
NoEdge                  = size(vec_uv_onp,1);

% ==============================
% computation
% -     configure by appending;
% ==============================
list_uv_ofp             = [];
list_cost_p             = [];
list_sefficiency_ofp    = [];
list_src_node_ofp       = [];
list_dst_node_ofp       = [];
list_kidx_ofp           = [];
list_nodePairNo_ofp     = [];
list_Ch_ofp             = [];
list_hop_ofp            = [];
list_Mod_ofp            = [];
list_strPath_ofp        = [];
for idx_config = 1 : size(LPonConfig, 2)
    if Repeated_Configurations(idx_config) >= 1
        rep_current     = Repeated_Configurations(idx_config);
        for idx_p = 1 : MAXIMUM_LPs_CONFIGURE
            if LPonConfig(idx_p,idx_config) == 0
                continue;
            end
            pid         = LPonConfig(idx_p, idx_config);
            if isempty(list_uv_ofp) ~= 0
                % initialize for first time
                list_uv_ofp          = [repmat(vec_uv_onp(1:NoEdge,pid), [1, rep_current])];
                list_cost_p          = [repmat(cost_p(pid), [1, rep_current])];
                list_hop_ofp         = [repmat(vec_hops_onp(pid), [1, rep_current])];
                list_sefficiency_ofp = [repmat(sefficiency_ofp(pid), [1, rep_current])];
                list_src_node_ofp    = [repmat(vec_src_node_ofp(pid), [1, rep_current])];
                list_dst_node_ofp    = [repmat(vec_dst_node_ofp(pid), [1, rep_current])];
                list_kidx_ofp        = [repmat(vec_kidx_ofp(pid), [1, rep_current])];
                list_nodePairNo_ofp  = [repmat(vec_nodePairNo_ofp(pid), [1, rep_current])];
                list_Ch_ofp          = [find(vec_ColoredConfigID_ofCh == idx_config)];
                list_Mod_ofp         = [repmat(vec_Mod_ofp(pid), [1, rep_current])];
                list_strPath_ofp     = [repmat(vec_strPath_ofp(pid), [1, rep_current])];
            else
                % otherwise, appending
                list_uv_ofp          = [list_uv_ofp,          repmat(vec_uv_onp(1 : NoEdge, pid), [1, rep_current])];
                list_cost_p          = [list_cost_p,          repmat(cost_p(pid), [1, rep_current])];
                list_hop_ofp         = [list_hop_ofp,         repmat(vec_hops_onp(pid), [1, rep_current])];
                list_sefficiency_ofp = [list_sefficiency_ofp, repmat(sefficiency_ofp(pid), [1, rep_current])];
                list_src_node_ofp    = [list_src_node_ofp,    repmat(vec_src_node_ofp(pid), [1, rep_current])];
                list_dst_node_ofp    = [list_dst_node_ofp,    repmat(vec_dst_node_ofp(pid), [1, rep_current])];
                list_kidx_ofp        = [list_kidx_ofp,        repmat(vec_kidx_ofp(pid), [1, rep_current])];
                list_nodePairNo_ofp  = [list_nodePairNo_ofp,  repmat(vec_nodePairNo_ofp(pid), [1, rep_current])];
                list_Ch_ofp          = [list_Ch_ofp,          find(vec_ColoredConfigID_ofCh == idx_config)];
                list_Mod_ofp         = [list_Mod_ofp,         repmat(vec_Mod_ofp(pid), [1, rep_current])];
                list_strPath_ofp     = [list_strPath_ofp,     repmat(vec_strPath_ofp(pid), [1, rep_current])];
            end
        end
    end
end

% ==============================
% Send to LightPathSet;
% ==============================
n = length(list_Mod_ofp);
LightPathSet = LightPath(n,NoEdge);

LightPathSet.nSize = n;
for pid = 1 : n
    % Assign constant;
    LightPathSet.transceiverNo(pid)        = 1;
    LightPathSet.nFrequencySlots(pid) = 1;
    
    % Assign connection info;
    LightPathSet.no(pid) = pid;
    LightPathSet.sourceNo(pid) = list_src_node_ofp(pid);
    LightPathSet.destinationNo(pid) = list_dst_node_ofp(pid);
    LightPathSet.routeNo(pid) = list_kidx_ofp(pid);
    LightPathSet.nodePairNo(pid) = list_nodePairNo_ofp(pid);
    LightPathSet.hops(pid) = list_hop_ofp(pid);
    
    LightPathSet.isPathUseEdges(pid, 1:NoEdge)= list_uv_ofp(1:NoEdge,pid);
    
    % Physical parameters
    LightPathSet.cost(pid)      = list_cost_p(pid);
    LightPathSet.capacity(pid)  = list_sefficiency_ofp(pid);
    LightPathSet.transmissionModeNo(pid) = list_Mod_ofp(pid);
    
    LightPathSet.wavelengthNo(pid) = list_Ch_ofp(pid);
    
    % Others
    LightPathSet.strPath(pid) = list_strPath_ofp(pid);
end

end
 
function block_pNoSet_ofConfig = removeWavelength(uLightPathSet, ColorlessLightPathSet)
%
%  Description:
%       pid(s,d,k,ch) -> ___pid(s,d,k)___ REPLACE_WITH_DASH_DASH> (pid,ch)
%  - pid(s,d,k,ch): uLightPathSet 
%  - pid(s,d,k) : ColorlessLightPathSet
%  - (pid,ch) : block_pNoSet_ofConfig
% 
%       remove wavelength of <uLightPathSet>, 
%       i.e., configuring lightpath block as noted by ColorlessLightPathSet;
% 
%  Detailed process:
%   The lightpaths computed by kSP-FF are separated by wavelength index.
%   They are converted into seperate wavelength configurations.
%   For each configuration, the source, destination, and route, i.e., 
%       (s,d,k), are kept except for wavlength index.
% 
%   Maximum configurations of NoNodes*(NoNodes-1) are considered
% 
% ==============================
% Derived from <fun_convert_LPs2LPbysdk.m>
% Author: cao chen;
% 
assert(isa(uLightPathSet, 'LightPath'),'error classes');
assert(isa(ColorlessLightPathSet, 'LightPath'),'error classes');

% ==============================
% Obtain parameters to be used;
% ==============================
MAX_LIGHTPATHS_CONFIGURE = size(ColorlessLightPathSet.isPathUseEdges,2);
MAX_WAVELENGTHS = max(uLightPathSet.wavelengthNo(:));

% ==============================
% Computation
% ==============================
block_pNoSet_ofConfig = zeros(MAX_LIGHTPATHS_CONFIGURE, MAX_WAVELENGTHS);
nLightPaths_ofConfig  = zeros(1, MAX_WAVELENGTHS);
for iLightPathSet = 1:uLightPathSet.nSize
    
    assert(uLightPathSet.sourceNo(iLightPathSet)>0, 'We have not define it');
    
    if(uLightPathSet.sourceNo(iLightPathSet)==0)
        break;
    end
    
    wChannel = uLightPathSet.wavelengthNo(iLightPathSet);
    idx  = ...
        find(...
         ColorlessLightPathSet.sourceNo(:)     == uLightPathSet.sourceNo(iLightPathSet) ...
        &ColorlessLightPathSet.destinationNo(:)== uLightPathSet.destinationNo(iLightPathSet) ...
        &ColorlessLightPathSet.routeNo(:)      == uLightPathSet.routeNo(iLightPathSet) ...
        &ColorlessLightPathSet.opticalBandNo(:)== uLightPathSet.opticalBandNo(iLightPathSet));
    if idx ~= 0
        pid = ColorlessLightPathSet.no(idx);
        nLightPaths_ofConfig(wChannel) = nLightPaths_ofConfig(wChannel) + 1;
        block_pNoSet_ofConfig(nLightPaths_ofConfig(wChannel), wChannel) = pid;
        
        assert(nLightPaths_ofConfig(wChannel)<=MAX_LIGHTPATHS_CONFIGURE, ...
            'Exceeding max lightpaths');
    end
end

end

function printTextToFile(fileName, headInfo, formatspec)
    fid = fopen(fileName,formatspec);
    fprintf(fid,'%s\n',headInfo);
    fclose(fid);
end

function handle = showNetworks(...
    distanceMatrix...
    , vec_longitude_ofn...
    , vec_latitude_ofn)
% Description:
%       
% Plot Networks on the earth (with longitude, latitude, and adjacentMatrix)
% 
% Author: cao.chen
% Date: Nov. 6th, 2023.
% ==============================

nNodes          = size(distanceMatrix,1);
vec_degree_ofn  = computeNodeDegree(distanceMatrix);
nEdges          = sum(vec_degree_ofn)/2;

handle          = digraph(distanceMatrix);
% ==============================
% Plot
% ==============================
figure(1);
clf;
plot(handle,'XData',vec_longitude_ofn,'YData',vec_latitude_ofn);
title(sprintf('Network graph with %d nodes, %d edges', nNodes,nEdges));
xlabel('');
ylabel('');
end

function deg = computeNodeDegree(adjacentMatrix)
% Compute degree of nodes;
deg = sum(adjacentMatrix,1);
end

function [ch, k] = ...
    revertChannelRoute(...
    indexing...
    , NUMBER_OF_CHANNELS...
    , NUMBER_OF_ROUTES...
    )
    % This function takes channel first, and route second.
    %     For example, 
    %     +REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH+REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH-+REPLACE_WITH_DASH_DASH+REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH+REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH+
    %     |                      |     NUMBER_OF_ROUTES=7    |  |                      |     NUMBER_OF_ROUTES=7     |
    %     +REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH+REPLACE_WITH_DASH_DASH-+REPLACE_WITH_DASH_DASH-+REPLACE_WITH_DASH_DASH-+REPLACE_WITH_DASH_DASH-+REPLACE_WITH_DASH_DASH-+REPLACE_WITH_DASH_DASH-+REPLACE_WITH_DASH_DASH-+REPLACE_WITH_DASH_DASH+REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH+REPLACE_WITH_DASH_DASH-+REPLACE_WITH_DASH_DASH-+REPLACE_WITH_DASH_DASH-+REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH+REPLACE_WITH_DASH_DASH-+REPLACE_WITH_DASH_DASH-+REPLACE_WITH_DASH_DASH-+
    %     |                      | 1 | 1 | 1 | 1 | 1 | 1 | 1 |  |                      | 0 | 1 | 2 | 3  | 4 | 5 | 6 |
    %     |                      +REPLACE_WITH_DASH_DASH-+REPLACE_WITH_DASH_DASH-+REPLACE_WITH_DASH_DASH-+REPLACE_WITH_DASH_DASH-+REPLACE_WITH_DASH_DASH-+REPLACE_WITH_DASH_DASH-+REPLACE_WITH_DASH_DASH-+REPLACE_WITH_DASH_DASH+                      +REPLACE_WITH_DASH_DASH-+REPLACE_WITH_DASH_DASH-+REPLACE_WITH_DASH_DASH-+REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH+REPLACE_WITH_DASH_DASH-+REPLACE_WITH_DASH_DASH-+REPLACE_WITH_DASH_DASH-+
    %     |                      | 1 | 1 | 1 | 1 | 0 | 0 | 0 |  |                      | 7 | 8 | 9 | 10 | - | - | - |
    %     |                      +REPLACE_WITH_DASH_DASH-+REPLACE_WITH_DASH_DASH-+REPLACE_WITH_DASH_DASH-+REPLACE_WITH_DASH_DASH-+REPLACE_WITH_DASH_DASH-+REPLACE_WITH_DASH_DASH-+REPLACE_WITH_DASH_DASH-+REPLACE_WITH_DASH_DASH+                      +REPLACE_WITH_DASH_DASH-+REPLACE_WITH_DASH_DASH-+REPLACE_WITH_DASH_DASH-+REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH+REPLACE_WITH_DASH_DASH-+REPLACE_WITH_DASH_DASH-+REPLACE_WITH_DASH_DASH-+
    %     | NUMBER_OF_CHANNELS=5 | 0 | 0 | 0 | 0 | 0 | 0 | 0 |  | NUMBER_OF_CHANNELS=5 | - | - | - | -  | - | - | - |
    %     |                      +REPLACE_WITH_DASH_DASH-+REPLACE_WITH_DASH_DASH-+REPLACE_WITH_DASH_DASH-+REPLACE_WITH_DASH_DASH-+REPLACE_WITH_DASH_DASH-+REPLACE_WITH_DASH_DASH-+REPLACE_WITH_DASH_DASH-+REPLACE_WITH_DASH_DASH+                      +REPLACE_WITH_DASH_DASH-+REPLACE_WITH_DASH_DASH-+REPLACE_WITH_DASH_DASH-+REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH+REPLACE_WITH_DASH_DASH-+REPLACE_WITH_DASH_DASH-+REPLACE_WITH_DASH_DASH-+
    %     |                      | 0 | 0 | 0 | 0 | 0 | 0 | 0 |  |                      | - | - | - | -  | - | - | - |
    %     |                      +REPLACE_WITH_DASH_DASH-+REPLACE_WITH_DASH_DASH-+REPLACE_WITH_DASH_DASH-+REPLACE_WITH_DASH_DASH-+REPLACE_WITH_DASH_DASH-+REPLACE_WITH_DASH_DASH-+REPLACE_WITH_DASH_DASH-+REPLACE_WITH_DASH_DASH+                      +REPLACE_WITH_DASH_DASH-+REPLACE_WITH_DASH_DASH-+REPLACE_WITH_DASH_DASH-+REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH+REPLACE_WITH_DASH_DASH-+REPLACE_WITH_DASH_DASH-+REPLACE_WITH_DASH_DASH-+
    %     |                      | 0 | 0 | 0 | 0 | 0 | 0 | 0 |  |                      | - | - | - | -  | - | - | - |
    %     +REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH+REPLACE_WITH_DASH_DASH-+REPLACE_WITH_DASH_DASH-+REPLACE_WITH_DASH_DASH-+REPLACE_WITH_DASH_DASH-+REPLACE_WITH_DASH_DASH-+REPLACE_WITH_DASH_DASH-+REPLACE_WITH_DASH_DASH-+REPLACE_WITH_DASH_DASH+REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH+REPLACE_WITH_DASH_DASH-+REPLACE_WITH_DASH_DASH-+REPLACE_WITH_DASH_DASH-+REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH+REPLACE_WITH_DASH_DASH-+REPLACE_WITH_DASH_DASH-+REPLACE_WITH_DASH_DASH-+
    % 
    %     Indexing: (ch,k): (ch-1) * NUMBER_OF_ROUTES + k
    %     Thus:
    %           ch = floor( (indexing-1) /NUMBER_OF_ROUTES ) + 1;
    %           k  = mod(indexing-1, NUMBER_OF_ROUTES)+1;
    % 
    ch = floor((indexing - 1) / NUMBER_OF_ROUTES ) + 1;
    k  = mod(indexing - 1, NUMBER_OF_ROUTES) + 1;
end

function [ch, k] = ...
    revertRouteChannel(...
    indexing ...
    , NUMBER_OF_CHANNELS ...
    , NUMBER_OF_ROUTES...
    )
    % This function takes route first, and channel second.
    %     For example,
    %     +REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH+REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH-+REPLACE_WITH_DASH_DASH+REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH+REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH-+
    %     |                      |     NUMBER_OF_ROUTES=7    |  |                      |     NUMBER_OF_ROUTES=7    |
    %     +REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH+REPLACE_WITH_DASH_DASH-+REPLACE_WITH_DASH_DASH-+REPLACE_WITH_DASH_DASH-+REPLACE_WITH_DASH_DASH-+REPLACE_WITH_DASH_DASH-+REPLACE_WITH_DASH_DASH-+REPLACE_WITH_DASH_DASH-+REPLACE_WITH_DASH_DASH+REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH+REPLACE_WITH_DASH_DASH-+REPLACE_WITH_DASH_DASH-+REPLACE_WITH_DASH_DASH-+REPLACE_WITH_DASH_DASH-+REPLACE_WITH_DASH_DASH-+REPLACE_WITH_DASH_DASH-+REPLACE_WITH_DASH_DASH-+
    %     |                      | 1 | 1 | 0 | 0 | 0 | 0 | 0 |  |                      | 0 | 5 | - | - | - | - | - |
    %     |                      +REPLACE_WITH_DASH_DASH-+REPLACE_WITH_DASH_DASH-+REPLACE_WITH_DASH_DASH-+REPLACE_WITH_DASH_DASH-+REPLACE_WITH_DASH_DASH-+REPLACE_WITH_DASH_DASH-+REPLACE_WITH_DASH_DASH-+REPLACE_WITH_DASH_DASH+                      +REPLACE_WITH_DASH_DASH-+REPLACE_WITH_DASH_DASH-+REPLACE_WITH_DASH_DASH-+REPLACE_WITH_DASH_DASH-+REPLACE_WITH_DASH_DASH-+REPLACE_WITH_DASH_DASH-+REPLACE_WITH_DASH_DASH-+
    %     |                      | 1 | 1 | 0 | 0 | 0 | 0 | 0 |  |                      | 1 | 6 | - | - | - | - | - |
    %     |                      +REPLACE_WITH_DASH_DASH-+REPLACE_WITH_DASH_DASH-+REPLACE_WITH_DASH_DASH-+REPLACE_WITH_DASH_DASH-+REPLACE_WITH_DASH_DASH-+REPLACE_WITH_DASH_DASH-+REPLACE_WITH_DASH_DASH-+REPLACE_WITH_DASH_DASH+                      +REPLACE_WITH_DASH_DASH-+REPLACE_WITH_DASH_DASH-+REPLACE_WITH_DASH_DASH-+REPLACE_WITH_DASH_DASH-+REPLACE_WITH_DASH_DASH-+REPLACE_WITH_DASH_DASH-+REPLACE_WITH_DASH_DASH-+
    %     | NUMBER_OF_CHANNELS=5 | 1 | 0 | 0 | 0 | 0 | 0 | 0 |  | NUMBER_OF_CHANNELS=5 | 2 | - | - | - | - | - | - |
    %     |                      +REPLACE_WITH_DASH_DASH-+REPLACE_WITH_DASH_DASH-+REPLACE_WITH_DASH_DASH-+REPLACE_WITH_DASH_DASH-+REPLACE_WITH_DASH_DASH-+REPLACE_WITH_DASH_DASH-+REPLACE_WITH_DASH_DASH-+REPLACE_WITH_DASH_DASH+                      +REPLACE_WITH_DASH_DASH-+REPLACE_WITH_DASH_DASH-+REPLACE_WITH_DASH_DASH-+REPLACE_WITH_DASH_DASH-+REPLACE_WITH_DASH_DASH-+REPLACE_WITH_DASH_DASH-+REPLACE_WITH_DASH_DASH-+
    %     |                      | 1 | 0 | 0 | 0 | 0 | 0 | 0 |  |                      | 3 | - | - | - | - | - | - |
    %     |                      +REPLACE_WITH_DASH_DASH-+REPLACE_WITH_DASH_DASH-+REPLACE_WITH_DASH_DASH-+REPLACE_WITH_DASH_DASH-+REPLACE_WITH_DASH_DASH-+REPLACE_WITH_DASH_DASH-+REPLACE_WITH_DASH_DASH-+REPLACE_WITH_DASH_DASH+                      +REPLACE_WITH_DASH_DASH-+REPLACE_WITH_DASH_DASH-+REPLACE_WITH_DASH_DASH-+REPLACE_WITH_DASH_DASH-+REPLACE_WITH_DASH_DASH-+REPLACE_WITH_DASH_DASH-+REPLACE_WITH_DASH_DASH-+
    %     |                      | 1 | 0 | 0 | 0 | 0 | 0 | 0 |  |                      | 4 | - | - | - | - | - | - |
    %     +REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH+REPLACE_WITH_DASH_DASH-+REPLACE_WITH_DASH_DASH-+REPLACE_WITH_DASH_DASH-+REPLACE_WITH_DASH_DASH-+REPLACE_WITH_DASH_DASH-+REPLACE_WITH_DASH_DASH-+REPLACE_WITH_DASH_DASH-+REPLACE_WITH_DASH_DASH+REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH+REPLACE_WITH_DASH_DASH-+REPLACE_WITH_DASH_DASH-+REPLACE_WITH_DASH_DASH-+REPLACE_WITH_DASH_DASH-+REPLACE_WITH_DASH_DASH-+REPLACE_WITH_DASH_DASH-+REPLACE_WITH_DASH_DASH-+
    % 
    %     Indexing funs: 
    %           (ch,k) : (k-1) * NUMBER_OF_CHANNELS + ch;
    %     Thus:
    %           ch  = mod(indexing-1, NUMBER_OF_CHANNELS)+1;
    %           k   = floor( (indexing-1) /NUMBER_OF_CHANNELS) + 1;
    ch  = mod(indexing - 1, NUMBER_OF_CHANNELS)+1;
    k   = floor( (indexing - 1) / NUMBER_OF_CHANNELS ) + 1;
end
##### SOURCE END #####
--></body></html>